---



---

数据结构

## 有一个夜晚我烧毁了所有的记忆，

## 从此我的梦就透明了；

## 有一个早晨我扔掉了所有的昨天，

## 从此我的脚步就轻盈了 。

## 1、线性表

### 1、1线性表的类型定义

- 一个线性表是n个数据元素的有限序列
- 在稍复杂的线性表中，一个数据元素可以由若干个数据项组成【在这种情况下，把数据元素称为**记录**】含有大量记录的线性表又称文件

> 表中每个学生情况为一个记录

| 姓名   | 学号  | 性别  | 年龄  | 班级 | 健康状况 |
| ------ | ----- | ----- | ----- | ---- | -------- |
| 王小领 | 32123 | 男    | 12    | 1    | 良好     |
| - - -  | - - - | - - - | - - - | - -  | - - -    |

#### 基本操作

- **InitList( &L )**
  操作结果:构造一个空的线性表L

- **DestroyList( &L )**
  初始条件:线性表L已存在。
  操作结果:销毁线性表L。

- **ClearList( &L )**
  初始条件:线性表L已存在。
  操作结果:将L重置为空表。

- **ListEmpty( L )**
  初始条件:线性表L已存在。
  操作结果:若L为空表,则返回TRUE,否则返回FALSE。

- **ListLength( L )**
  初始条件:线性表L已存在。
  操作结果:返回L中数据元素个数。

- **GetElem( L, i, &e )**
  初始条件:线性表L已存在,1≤i≤ListLength(L)。
  操作结果:用e返回L中第i个数据元素的值。

- **LocateElem( L, e, compare() )**
  初始条件:线性表L已存在，compare()是数据元素判定函数。
  操作结果:返回L中第1个与e满足关系compare()的数据元素的位序。若这样的数据元素
  不存在,则返回值为0。

- **PriorElem( L, cur_e, &pre_e )**
  初始条件:线性表L已存在。
  操作结果:若cur_e是L的数据元素，且不是第一个,则用pre_e返回它的前驱,否则操作
  失败,pre_e无定义。

- **NextElem( L，cur_e，&next_e )**
  初始条件:线性表L已存在。
  操作结果:若cur_e是L的数据元素,且不是最后一个,则用next_e返回它的后继，否则操
  作失败,next_e无定义。

- **ListInsert( &L，i, e )**
  初始条件:线性表L已存在,1 ≤ i ≤ ListLength(L) + 1。.
  操作结果:在L中第i个位置之前插人新的数据元素e,L的长度加1。

- **ListDelete(&L, i, &e)**

  初始条件:线性表L已存在且非空,1≤i≤ListLength(L)。
  操作结果:删除L的第i个数据元素,并用e返回其值,L的长度减1。

- **ListTraverse(L, visit())**
  初始条件:线性表L已存在。
  操作结果:依次对L的每个数据元素调用函数visit()。一旦visit()失败,则操作失败

***

### 1、2线性表的顺序存储

```c
//-----线性表的动态分配顺序存储结构
#define LIST.INIT.SIZE 100	//线性表存储空间的初始分配量
#define LISTINCREMENT 10	//线性表存储空间的分配增量
typedef struct {
    ElemType * elem;		//存储空间基址
    int length; 			//当前长度
    int listsize;			//当前分配的存储容量(以sizeof( ElemType)为单位)
}SqList;

```

- **初始化线性表**

```c
Status InitList_Sq(SqList &L) {
    //构造一个空的线性表L
    L.elem = (E1emType * )mal1oc(LIST_INIT_SIZE * sizeof(ElemType));
    if (!L.elem) exit(OVERFLOW); 	// 存储分配失败
    L.length = 0;//空表长度为0
    L.listsize = LIST.INIT.SIZE; 	// 初始存储容量
    return OK;
}// InitList- Sq
```

- **插入元素**

```c
Status ListInsert_Sq(SqList &L, int i, ElemType e) {
    //在顺序线性表L中第i个位置之前插人新的元素e,
    // i的合法值为1 ≤ i ≤ ListLength_Sq(L) + 1
    if(i < 1 || i > L.length + 1) return ERROR; // i值不合法
    if (L.length >= L.listsize) { // 当前存储空间已满,增加分配
    newbase = (ElemType * )realloc(L.elem,
    	(L.listsize + LISTINCREMENT) * sizeof ( E1emType));
    if(!newbase) exit(OVERFLOW); // 存储分配失败
    L.elem = newbase;//新基址
    L.listsize += LISTINCREMENT;//增加存储容量
    q = &(L.elem[i - 1]);// q为插人位置
    for (p = &(L.elem[L.length - 1]); p >= q; --p) 
        *(p + 1) =*p;//插人位置及之后的元素右移
    *q = e;//插人e
    ++ L.length;//表长增1
    return OK; 
} // ListInsert- Sq
```

- **线性表删除操作**

```c
Status ListDelete_Sq(SqList &L，int i, ElemType &e) {.
    //在顺序线性表L中删除第i个元素,并用e返回其值
    // i的合法值为1≤i≤ListLength_ Sq(L)
    if ((i < 1) || (i > L.length)) return ERROR; // i值不合法
    p = & (L.elem[i - 1]);			//p为被删除元素的位置
    e = *p;							//被删除元素的值赋给e
    q = L.elem + L. length - 1;		//表尾元素的位置
    for( ++p; p <= q; ++p) *(p - 1) = *p;	//被删除元素之后的元素左移.
	-- L.lenth;
    return OK;
}
```

- **线性表合并**

```c
void MergeList_Sq(SqList La, SqList Lb, SqList &Lc) {
    //已知顺序线性表La和Lb的元素按值非递减排列
    //归并La和Lb得到新的顺序线性表Lc,Lc的元素也按值非递减排列
    pa = La.elem; pb = Lb.elem;
    Lc.listsize = Lc.length = La.length + Lb.length;
    pc = Lc.elem = (ElemType *) mal1oc(Lc.listsize * sizeof (E1emType));
    if (!Lc.elem) exit(OVERFLOW); 			// 存储分配失败
    pa_last = La.elem + La.length - 1;
    pb_last = Lb.elem + Lb.length - 1;
    while (pa <= pa_last && pb <= pb_last) {//归并
    if ( *pa <= *pb) 
        *pc++ = *pa++;
    else
        *pc++ = *pb++;
    }
    while (pa <= pa_last) * pc++ = * pa++ ;//插人La的剩余元素
    while (pb <= pb_last) * pc++ = * pb++ ;//插入Lb的剩余元素
} // MergeList_ Sqc
```

***

### 1、3线性表的链式存储

```c
typedef struct LNode {
    ElemTyp data ; 
    struct LNode* next;
} LNode, * LinkList;
```

- 有时，我们在单链表的第一个结点之前附设一个结点，称之为头结点
- 头结点的数据域可以不存储任何信息，也可存储如线性表的长度等类的附加信息，头结点的指针域存储指向第一个结点的指针(即第一个元素结点的存储位置)

***

- **插入元素**

```c
Status ListInsert_L(LinkList &L，int i, ElemType e) {
    //在带头结点的单链线性表L中第i个位置之前插入元素e
    p = L; j = 0;
    while( p && j < i - 1) { p = p->next; ++j; } 		// 寻找第i-1个结点
	if (!p || j > i - 1) return ERROR;				// i小于1或者大于表长加1
	s = (LinkList)malloc(sizeof(LNode)) ;			//生成新结点
    s->data = e; 
    S->next = p->next;	// 插人L中
    p->next = s;
    return OK;
    } // ListInsert L
```

- **删除元素**

```c
Status ListDelete_L( LinkList &L, int i, ElemType &e) {
    // 在带头结点的单链线性表 L ，删除第i个元素,并由e返回其值
    p = L;j = 1;
    while( p->next && j < i - 1){  				//寻找第i个结点,并令p指向其前趋
    p = p-->next; 十卜j;
    if (!(p->next) | j > i--l) return ERROR ;	// 删除位置不合理
    q = P-> next; P. > next = q--> next;		//删除并释放结点
    e = q->data;
    free(q) ;
    return OK;
} // ListDelete L
```

- **合并列表**

```c
void MergeList. L(LinkList &La, LinkList &Lb, LinkList &Lc) {
    //已知单链线性表La和Lb的元素按值非递减排列。
    //归并La和Lb得到新的单链线性表Lc,Lc的元素也按值非递减排列。
    pa = La->next; pb = Lb-> next;
    Lc = p c= La; 				//用La的头结点作为Lc的头结点
    while ( pa && pb) {
    if (pa->data <= pb->data) {
    pc->next = pa; pc = pa; pa = pa-> next;
    }
    else {pc->next = pb; pc = pb; pb = pb->next; }
    }
    pc-> next =  pa? pa : pb;	//插人剩余段
    free(Lb) ;					//释放Ib的头结点
}// MergeList_ L
```

***

#### 静态链表

```c
//-----线性表的静态单链表存储结构- - - -一
#define MAXSIZE 1000 // 链表的最大长度
typedef struct{
	ElemType data;
    int cur;
} component, SLinkList[MAXSIZE];
```

- 假设S为SLinkList型变量，则S[0].cur指示第一个结点在数组中的位置，若设 i=S[0]. cur ,则S[i]. data存储线性表的第一个数据元素，且 S[i]. cur 指示第二个结点在数组中的位置
- 一般情况，若第 i 个分量表示链表的第 k 个结点,则 S[i]. cur 指示第 k+1 个结点的位置

- **寻找元素**

```c
int LocateElem_SL(SLinkList S, ElemType e) {
    //在静态单链线性表L中查找第1个值为e的元素。
    //若找到，则返回它在L中的位序,否则返回0。
    i = s[0].cur;				// i指示表中第一个结点
    while (i && S[i].data != e) i= s[i].cur;	//在表中顺链查找
    return i;
} // LocateE1em.SL
```

- 为了辨明数组中哪些分量未被使用，解决的办法是将所有**未被使用过以及被删除的分量**用游标链成一个**备用的链表**
  - 每当进行插人时便可从备用链表上取得第一个结点作为待插人的新结点；
  - 反之，在删除时将从链表中删除下来的结点链接到备用链表上。

```c
void Init_space(SLinkList space){
    int i = 0;					//space[0].cur 为头指针,指向第一个链表元素
    for(i;i < MAXSIZE - 1; i++)
        space[i].cur = i + 1;
    space[MAXSIZE-1].cur = 0;	//
}

int Malloc_SL(SLinkList space){
    //若链表非空，返回链表第一个分配的结点下标
	int i = space[0].cur;
    if(space[0].cur) 
        space[0].cur = space[i].cur;
    return i;
}

void Free_SL(SLinkList space, int k){
    //将下标为k的结点回收到备用链表
    space[k].cur = space[0].cur;
    space[0].cur = k;
}

void difference(SLinkList space, int &S){
    Init_space(space);			//初始化链表
    S = Malloc_SL(space);		//S为第一个空闲结点
    int r = S;					//r记录S最后一个结点
    int m,n,i,j,b;
    scanf("%d%d",&m,&n);		//输入A和B的元素个数
    for( j = 1; j <= m; j++){	//建立集合A链表
		i = Malloc_SL(space);
        scanf("%d",&space[i].data);
        space[r].cur = i;
        r = i;
    }
    space[r].cur = 0;
    for(j = 1;j <= n; j++){
        scanf("%d",&b);
        int p = S,k = space[S].cur;
    	while(k != space[r].cur && space[k].data != b){
            p = k;
            k = space[k].cur;
        }
        if(k == space[r].cur){
            i = Malloc_SL(space);
            space[i].data = b;
            space[i].cur = space[r].cur;
            space[r].cur = i;
        }
        else{				//该元素在表中，要删除
            space[p].cur = space[k].cur;
            Free_SL(space,k);
            if(r == k) 
                r = p;		//若删除的是r所指结点，修改尾指针
        }
    }
}
```

***

#### 双向链表

```c
/-----线性表的双向链表存储结构–--- -/
typedef struct DuLNode {
    ElemType data;
    struct DuLNode* prior;
	struct DuLNode* next;
}DuLNode,*DuLinkList;
```

- 在ListLenth、GetElem、LocateElem 等单向操作与线性链表相同，在插入删除不同

```c
//删除操作
Status ListDelete_DuL(DuLinkList &L, int i, ElemType *e){
    //带头节点的链表进行删除第i个元素
    if(!(p = GetElemP_DuL(L,i)))	//在L中确定第i个元素的位置指针p
        return ERROR;				//p = NULL即第i个元素不存在
    e = p->data;
    p->prior->next = p->next;
    p->next->prior = p->prior;
    free(p);
    return OK;
}

//插入元素
Status ListInsert_DuL(DuLinkList &L, int i, ElemType e){
    if(!(p = GetElemP_DuL(L,i)))	//在L中确定第i个元素的位置指针p
        return ERROR;
    if(!(s = (DuLinkLink)malloc(sizeof(DuLNode))))
        return ERROR;
    s->data = e;
    s->prior = p->prior;
    p->prior->next = s;
    s->next = p;
    p->prior = s;
    return OK;
}
```

***

## 2、栈和队列

### 2、1栈

- **抽象数据类型栈的定义**
  栈(stack)是限定仅在表尾 进行插人或删除操作的线性表。
  - 因此,对栈来说,表尾端有其特殊含义,称为**栈顶(top)**,
  - 相应地,表头端称为栈底(bottom)。
  - 不含元素的空表称为空栈。
    - 假设栈 $S= (a_1 ,a_2,.,a_n)$,则称
      a1为栈底元素,an为栈顶元素。栈中元素按a1，a2,..,an的次序进栈,退栈的第一个元素应为栈顶元素。
    - 换句话说,栈的修改是按后进先出的原则进行的
    - 因此,栈又称为后进先出(last in first out) 的线性表(简称LIFO结构)

#### 基本操作

- **InitStack( &S)**
  操作结果:构造一个空栈S。
- **DestroyStack(&S)**
  初始条件:栈S已存在。
  操作结果:栈S被销毁。
- **ClearStack( &S).**
  初始条件:栈S已存在。
  操作结果:将S清为空栈。
- **StackEmpty(S)**
  初始条件:栈S已存在。
  操作结果:若栈S为空栈,则返回TRUE,否则FALSE。
- **StackLength(S)**
  初始条件:栈S已存在。
  操作结果:返回S的元素个数，即栈的长度。
- **GetTop(S, &e)**
  初始条件:栈S已存在且非空。
  操作结果:用e返回S的栈顶元素。
- **Push(&s, e)**
  初始条件:栈S已存在。
  操作结果:插人元素e为新的栈顶元素。
- **Pop(&s，&e)**
  初始条件:栈S已存在且非空。
  操作结果:删除S的栈项元素,并用e返回其值。
- **StackTraverse(S, visit())**
  初始条件:栈s已存在且非空。
  操作结果:从栈底到栈顶依次对S的每个数据元素调用函数visit（）

#### **栈的链式表示和实现**

- 和线性表类似,栈也有两种存储表示方法。

  - 顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。
    
  - 通常的习惯做法是以top=0表示空栈,鉴于C语言中数组的下标约定从0开始，则当以C作描述语言时,如
    此设定会带来很大不便;另一方面，由于栈在使用过程中所需最大空间的大小很难估计，因此,一般来说，在初始化设空栈时不应限定栈的最大容量。
    
  - 一个较合理的做法是：先为栈分配一个基本容量，然后在应用过程中，当栈的空间不够使用时再逐段扩大。
    
    - 设定两个常量:**STACK_ INIT_ SIZE**(存储空间初始分配量)和**STACKINCREMENT**(存储空间分配增量)，并以下述类型说明作为顺序栈的定义。
    
    ```c
    #define STACK_ INIT_ SIZE 100	//存储空间初始分配量
  #define STACKINCREMENT 10		//存储空间分配增量
    typedef struct{
        SElemType  *base;
        SElemType  *top;
        int  stacksize;				//栈当前可使用的最大容量
    }SqStack;
    ```

  ![img](C:\Users\13793\Desktop\学习笔记\数据结构\[YK0J7WB1YRH7{XJOPTSBG.png)

- **构造一个空栈**

  ```c
  Status InitStack (SqStack &S) {
      //构造一个空栈s
      S.base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType));
      if (!S. base) exit (OVERFLOW); // 存储分配失败
      S.top = S. base;
      S.stacksize = STACK_ INIT_SIZE;
      return OK;
  }// InitStack
  ```

- **栈顶元素**

  ```c
  Status GetTop( SqStack S, SElemType &e) {
      //若栈不空,则用e返回S的栈顶元素,并返回0K;否则返回ERROR
      if (S.top == S. base) return ERROR;
      e = *(S. top- 1);
      return OK;
  }// GetTop ;
  ```

- **插入元素**

  ```c
  Status Push (SqStack &s, SElemType e) {
      //插人元素e为新的栈项元素
      if (S.top - S.base >= S. stacksize) {		// 栈满,追加存储空间
          S.base = (SElemType *) realloc(S.base,
          		(S.stacksize + STACKINCREMENT) * sizeof (SElemType));
          if (!S. base) exit (OVERFLOW); 				// 存储分配失败
          S.top = S.base + S.stacksize;
          S.stacksize += STACKINCREMENT;
      }
      *S.top ++ = e;
      return 0K;
  } //Push
  
  Status Push(SqStack *S, SElemType e){
      if((S->top - S->base) > STACK_INIT_SIZE) {       //栈满，追加空间
          S->base = (SElemType*)realloc(S->base,(S->stacksize + STACKINCREMENT)*sizeof(SElemType));
          if(!S->base)
              exit(OVERFLOW);
          S->top = S->base + S->stacksize;
          S->stacksize += STACKINCREMENT;
      }
      *S->top = e;
      *(S->top) ++;
      return OK;
  }
  ```

- **删除元素**

  ```c
  Status Pop (SqStack &s, SElemType &e) {
      //若栈不空,则删除S的栈顶元素,用e返回其值,并返回0K;否则返回ERROR
      if (S. top == S. base) return ERROR;
      e = *--S.top;
      return OK;
  }// Pop
  ```

***

#### 栈的应用

- **中缀表达式的转换**

  ![img](C:\Users\13793\Desktop\学习笔记\数据结构\OTPOUO`L{`FUI%TJV7N5]JC.png)

- **进制转换**

```c
void conversion () {
    //对于输人的任意一个非负十进制整数,打印输出与其等值的八进制数
    InitStack(S);
    //构造空栈
    scanf ("%d" ,&N) ;
    while (N) {
        Push(S，N % 8);
        N = N/8;
        while (!StackEmpty(s)) {
            Pop(S,e);
            printf ( "%d", e );
} // conversion
```

- **括号匹配的检验**

  ```c
  BOOL BracketCorrespondency(char a[])
  {
      int i = 0;
      SqStack S ;
      InitStack(S) ;
      ElemType x;
      while(a[i]){
          switch(a[i]) {
              case '(': Push(s,a[i]); break;
              case '[': Push(s,a[i]); break;
              case ')': 
                  GetTop(s,x);
                  if(x=='(')
              	Pop(s,x);
              	else return FALSE;
              	break;
              case ']':
                  GetTop(s,x);
                  if(x=='[') Pop(s,x);
                  else return FALSE;
                  break;
              default:
              	break;
          }
      	i++;
      }
      if(s.size!=0) return FALSE;
      return TRUE;
  }
  ```

- **行编辑程序**

  ```c
  void LineEdit() {
      //利用字符栈S,从终端接收一行并传送至调用过程的数据区。
      InitStack(S) ;
      //构造空栈S
      ch = getchar();
      //从终端接收第一个字符
      while(ch != EOF){		//E0F为全文结束符
          while (ch != EOF && ch != '\n') {
              switch (ch){
                  case '#': Pop(S, c);
                  break;		//仅当栈非空时退栈
                  case' @': ClearStack(S) ;
                  break;		// 重置S为空栈
                  default : Push(S, ch) ;
                  break;		//有效字符进栈,未考虑栈满情形.
              }
              ch = getchar(); //从终端接收下一个字符
          }
          将从栈底到栈顶的栈内字符传送至调用过程的数据区;
          ClearStack(S) ;
          //重置S为空栈
          if (ch != E0F) ch = getchar();
      }
      DestroyStack(S);
  } // LineEdit
  ```

- **迷宫求解**

  ```c
  typedef struct {
      int ord;		//通道块在路径上的"序号"
      PosType seat;	//通道块在迷宫中的"坐标位置"
      int di;			//从此通道块走向下一通道块的"方向"
  } SElemType;		//栈的元素类型
  Status MazePath (MazeType maze, PosType start, PosType end) {
      //若迷宫maze中存在从入口start到出口end的通道,则求得一条存放在栈中(从栈底到栈
      //顶),并返回TRUE;否则返回FALSE
      InitStack(S); 
      curpos = start;		//设定"当前位置"为"人口位置"
      curstep = 1;		// 探索第一步
      do {
          if(Pass (curpos)) { // 当前位置可以通过,即是未曾走到过的通道块
          FootPrint (curpos) ;
          //留下足迹
          e =( curstep, curpos, 1 );
          Push (S,e);
          //加人路径
          if (curpos == end) return (TRUE); // 到达终点(出口)
          curpos = NextPos ( curpos, 1 );
          //下一位置是当前位置的东邻
          curstep++ ;
          //探索下一步 
          }
          else{ // 当前位置不能通过
              if (!StackEmpty(S)) {
                  Pop (S,e) ;
                  while (e.di==4 && ! StackEmpty(S)) {
                      MarkPrint (e. seat); Pop (S,e) ;
                      // 留下不能通过的标记,并退 回一步
              	} 
              if (e.di<4) {
              e.di ++ ;
              Push ( S, e);
              //换下一个方向探索
              curpos = NextPos (e.seat e.di);
              //设定当前位置是该新方向上的相邻块;
          			}
          		}
          	}
          }while (!StackEmpty(S) );
       return (FALSE) ;
  } // MazePath
  ```
  
- **表达式求值**

  ```
  
  ```

***

### 2、2队列

- **定义**

  队列是一种**先进先出的线性表**（FIFO），允许在表的移断插入元素，另一端删除元素

- 允许插入的一端为队尾，允许删除的一端为队头

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\]R10CB%R{MR}E1GKAS]FUI.png" alt="img" style="zoom: 66%;" />

***

#### 队列的链式表示

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\$K$I3$XR7XG_3MK3GK$ANS.png" alt="img" style="zoom: 67%;" />

***

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\O]UBQ6%%%U%QG4SUKQXUF%7.png" alt="img" style="zoom:67%;" />

***

#### 基本操作

- **InitQueue( &Q)**
  操作结果:构造一个空队列Q。
- **DestroyQueue( &Q)**
  初始条件:队列Q已存在。
  操作结果:队列Q被销毁,不再存在。
- **ClearQueue( &Q)**
  初始条件:队列Q已存在。
  操作结果:将Q清为空队列。
- **QueueEmpty(Q)**
  初始条件:队列Q已存在。
  操作结果:若Q为空队列,则返回TRUE,否则FALSE。
- **QueueLength(Q)**
  初始条件:队列Q已存在。
  操作结果:返回Q的元素个数,即队列的长度。
- **GetHead(Q, &e)**
  初始条件:Q为非空队列。
  操作结果:用e返回Q的队头元素。
- **EnQueue(&Q, e)**
  初始条件:队列Q已存在。
  操作结果:插人元素e为Q的新的队尾元素。
- **DeQueue(&Q, &e)**
  初始条件:Q为非空队列。
  操作结果:删除Q的队头元素,并用e返回其值。
- **QueueTraverse(Q, visit())**
  初始条件: 0已存在且非空。
  操作结果:从队头到队尾,依次对Q的每个数据元素调用函数visit()。一旦visit()
  失败,则操作失败。

***

```c
typedef struct QNode {
    QElemType data;
    struct QNode *next;
}QNode, *QueuePtr;

typedef struct {
    QueuePtr front; // 队头指针
    QueuePtr rear; //队尾指针
}LinkQueue;
```

***

- **算法描述**

  - **初始化队列**

    ```c
    Status InitQueue(LinkQueue &Q){
        Q.front = Q.rear = (QueuePtr)malloc (sizeof(QNode));
        if(!Q.front) exit(OVERFLOW);
        Q.front = NULL;
        return OK;
    }
    ```

  - **销毁队列**

    ```c
    Status DestroyQueue(LinkQueue &Q){
    	while(Q.front){
            Q.rear = Q.front->next;
            free(Q.front);
            Q.front = Q.rear;
        }
        return OK;
    }
    ```

  - **插入元素**

    ```c
    Status EnQueue(LinkQueue &Q, QElemType){
    	P = (QueuePtr)malloc(sizeof (*QNode));
        if(!p) exit(OVERFLOW);
        p->date = e, p->next = NULL;
        Q.rear->next = p;
        Q.rear = p;
        return OK;
    }
    ```

  - **删除元素**

    ```c
    Status DeQueue(LinkQueue &Q, QElemType &e){
        if(Q.front == Q.rear) return ERROR;
    	p = Q.front->next;
        e = p.data;
        Q.front->next = p->next;
        if(Q.rear == p) Q.rear = Q.front;
        free(p);
        return OK;
    }
    ```

***

#### **队列的顺序表示**

- 为了在C语言中描述方便起见,在此我们约定:初始化建空队列时，令**front=rear=0**
  - 每当**插人队列尾元素**时，“**尾指针增1**”
  - 每当**删除队列头元素**时,“**头指针增1**”。
- 因此,在非空队列中,头指针始终指向队列头元素,而尾指针始终指向队列尾元素的下一个位置

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\QQ图片20200617203333.png" style="zoom: 50%;" />

- 只凭等式 **Q. front= Q. rear** 无法判别队列空间是“空”还是“满”。
  - 可有两种处理方法:其一是另设一个标志位以区别队列是“空”还是“满”;
  - 其二是少用一个元素空间,约定以 “**队列头指针在队列尾指针的下一位置(指环状的下一位置)上”**作为队列呈“满”状态的标志。

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\(9YEO6V1MFY{RFTD9A0)1H.png" alt="img" style="zoom: 50%;" />

***

#### 基本操作

```c
#define MAXQSIZE 10  		//最大队列长度
typedef struct {
	QE1emType* base;		//初始化的动态分配存储空间.
    int front;				//头指针,若队列不空,指向队列头元素
    int rear ;				//尾指针,若队列不空,指向队列尾元素的下一个位置
}SqQueue;
```

// -----循环队列的基本操作的算法描述-----

- **初始化队列**

  ```c
  Status InitQueue (SqQueue &Q) {
      //构造一个空队列Q
      Q.base = (QE1emType *) malloc (MAXQSIZE * sizeof (QE1emType));
      if (! Q.base) exit (OVERFL0W); // 存储分配失败
      Q.front = Q.rear = 0;
      return OK;
  }
  ```
  
- **返回元素个数**

  ```c
  int QueueLength (SqQueue Q) {
      //返回Q的元素个数,即队列的长度
      return (Q. rear - Q. front + MAXQSIZE) % MAXQSIZE ;
  }
  ```

- **插入元素**

  ```c
  Status EnQueue (SqQueue &Q，QElemType e) {
      //插人元素e为Q的新的队尾元素
      if ((Q.rear+ 1) % MAXQSIZE == Q.front) return ERROR; //队列满
      Q.base[Q.rear] = e;
      Q.rear = (Q.rear + 1) % MAXQSIZE;
      return OK;
  }
  ```

- **删除元素**

  ```c
  Status DeQueue (SqQueue &Q, QElemType &e) {
      //若队列不空,则删除Q的队头元素,用e返回其值,并返回OK;
      //否则返回ERROR
      if (Q. front == Q. rear) return ERROR;
      e = Q. base[Q. front];
      Q. front = (Q. front+ 1) % MAXQSIZE; 
      return OK;
  }
  ```

****

#### 离散事件模拟







***

## 3、串

### 3、1串的定义

- **串**是由零个或多个字符组成的有限序列

  - 一般记为：s = ‘a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>…a<sub>n</sub>’	(n >= 0)

    > - s是串的名，用单引号括起来的字符序列是串的**值**;
    >
    > - a(1≤i≤n)可以是**字母、数字或其他字符**;
    > - 串中字符的数目n称为串的长度。
    > - 零个字符的串称为空串(null string)，它的长度为零。

  - 串中任意个**连续**的字符组成的子序列称为该串的**子串**，包含子串的串相应地称为**主串**

  - 通常称**字符在序列中的序号**为该字符在串中的**位置**

  - 子串在主串中的位置则以子串的**第一个字符在主串中的位置**来表示

    - 称两个串是相等的, 当且仅当这两个串的值相等。
    - 也就是说, 只有当两个串的**长度相等**, 并且**各个对应位置的字符都相等**时才相等。

  - 由一个或多个空格组成的串' '称为空格串 (blank string, 请注意:此处不是空串)。它的长度为串中空格字符的个数。为了清楚起见,以后我们用符号“φ”来表示“空串”。

- **串赋值StrAssign、串比较StrCompare、求串长StrLength、串联接Concat以及求子串SubString**
  操作构成串类型的最小操作子集，其他串操作 ( 除串清除ClearString和串销毁DestroyString外 ) 均可在这个最小操作子集上实现。

#### 基本操作

- **StrAssign (&T, chars)**
  初始条件:chars是字符串常量。
  操作结果:生成一个其值等于chars的串T。
- **StrCopy (&T, S)**
  初始条件:串S存在。
  操作结果:由串S复制得串T。
- **StrEmpty (S)**
  初始条件:串S存在。
  操作结果:若S为空串,则返回TRUE,否则返回FALSE。
- **StrCompare (S，T)**
  初始条件:串S和T存在。
  操作结果:若S> T,则返回值 > 0;若S = T,则返回值= 0;若S < T,则返回值 < 0。
- **StrLength (S)**
  初始条件:串S存在。
  操作结果:返回S的元素个数,称为串的长度。
- **ClearString (&S)**
  初始条件:串S存在。
  操作结果:将S清为空串。
- **Concat (&T, S1, S2)**
  初始条件:串S1和S2存在。
  操作结果:用T返回由S1和S2联接而成的新串。
- **SubString (&Sub, S, pos, len)**
  初始条件:串S存在,1≤pos≤StrLength(S)且0≤len≤StrLength(S) - pos+ 1。，
  操作结果:用Sub返回串S的第pos个字符起长度为len的子串。
- **Index (S, T, pos)**
  初始条件:串S和T存在,T是非空串,1≤pos≤StrLength(S)。
  操作结果:若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第
  一次出现的位置;否则函数值为0。
- **Replace (&s, T, V)**
  初始条件:串S,T和V存在,T是非空串。
  操作结果:用V替换主串S中出现的所有与T相等的不重叠的子串。
- **StrInsert (&S, pos, T)**
  初始条件:串S和T存在.1≤ pos ≤ StrLength(S) + 1。
  操作结果:在串S的第pos个字符之前插入串T。
- **StrDelete ( &S,  pos，len)**
  初始条件:串S存在，1 ≤ pos≤StrLength(S)- 1en+ 1。
  操作结果:从串S中删除第pos个字符起长度为len的子串。
- **DestroyString ( &S)**
  初始条件:串S存在。
  操作结果:串S被销毁。

***

### 3、2串的表示和实现

#### 定长顺序存储表示

```c
#define MAXSTRLEN 250
tpyedef unsigned char SString[MAXSTRLEN + 1]；
```

***

- **串连接**

```c
Status Concat( SString &T, SString S1, SString S2) {
    //用T返回由S1和S2联接而成的新串。若未截断，则返回TRUE,否则FALSE。
    if (S1[0]+ S2[0] < = MAXSTRLEN) {
        //未截断
        T[1..S1[0]] = S1[1..S1[0]];
        T[S1[0]+ 1..S1[0]+ s2[0]] = S2[1.. s2[0]];
        T[0] = S1[0]+ S2[0];
        uncut = TRUE;
    }
    else if (S1[0] < MAXSTRLEN) {
        //截断
        T[1..S1[0]] = S1[1.. S1[0]];
        T[s1[0] + 1.. MAXSTRLEN] = S2[1. . MAXSTRLEN- S1[0]];
        T[0] = MAXSTRLEN; 
        uncut = FALSE;
    }
    else {
        //截断(仅取S1)
        T[0. . MAXSTRLEN] = S1 [0. . MAXSTRLEN];
        // T[0] == s1[0] == MAXSTRLEN
		uncut = FALSE;
    }
    return uncut;
}
```

- **求子串**

```c
Status SubString(SString &Sub, SString S, int pos, int len){
    if(pos < 1 || pos > S[0] || len < 1 || len > s[0] - pos +1)
        return ERROR;
    Sub[1..len] = S[pos..pos + len -1];
    Sub[0] = len;
    return OK;
}
```

***

#### 堆分配存储表示

```c
typedef struct{
	char *ch;
    int lenth;
}HString;
```

- **插入串**

```c
Status StrInsert(HString &S, int pos, HString T){
    if(pos < 1 || pos > S.lenth + 1) return ERROR;
    if(T.lenth){
        if(!(S.ch = (char *)realloc(ch, (S.lenth + T.lenth)*sizeof(char))))
            exit(OVERFLOW);
        for(i = S.lenth - 1; i >= pos - 1; i--)
            S.ch[i + T.lenth] = S.ch[i];
        S.ch[pos-1...pos + T.lenth -1] = T.ch[0...T.lenth - 1];
        S.lenth += T.lenth;
    }
    return OK;
}
```

***

##### 堆分配的基本操作

- **生成串**

```c
Status StrAssign(HString &T, char *chars){
    if(T.ch) free(T.ch);
    for(i = 0, c = chars; c ; i++,c++)
    if(!i){
        T.ch = NULL;
        T.lenth = 0;
    }
    else{
        if(!(T = (char*)malloc(i*sizeof(char))));
        	exit(OVERFLOW);
        T.ch[0...i-1] = char[0...i-1];
        T.lenth = i;
    }
    return OK;
}
```

- **返回元素个数**

```c
int StrLenth(HString &S){
    return S.lenth;
}
```

- **串比较**

```c
int StrCompare(HString &S, HString &T){
    for(i = 0; i<S.lenth && i<T.lenth;i++)
        if(S.ch[i] != T.ch[i]) return (S.ch[i] - T.ch[i]);
    return S.lenth - T.lenth;
}
```

- **删除串**

```c
Status ClearString(HString &S){
    if(S.ch) {
        free(S.ch);
        S.ch = NULL;
    }
    S.lenth = 0;
    return OK;
}
```

- **拼接串**

```c
Status Concat( HString &T, HString S1, HString S2) {
    //用T返回由S1和S2联接而成的新串。
    if (T.ch) free(T.ch) ;
    //释放旧空间
    if (!(T.ch = (char *) malloc((S1. length + S2. length) * sizeof(char))))
    	exit (OVERFLOW) ;
    T.ch[0..S1.length-1] = S1.ch[0..S1.length- 1];
    T.length = S1.length + S2.length;
    T.ch[S1.length..T.1ength-1] = S2.ch[0..S2.length - 1];
    return OK;
}// Concat
```

- **返回子串**

```c
Status SubString(HString &Sub, HString S, int pos, int len) {
    //用Sub返回串S的第pos个字符起长度为len的子串。
    //其中,1 ≤ pos ≤ StrLength(S)且0 ≤ 1en ≤ StrLength(S)- pos+ 1.
    if (pos< 1 || pos > s.length || len<0 || len > S.length - pos + 1)
    	return ERROR;
    if (Sub.ch) free(Sub.ch) ;	//释放旧空间
    if (!len) {
        Sub.ch = NULL; 
        Sub.length = 0; 
    }//空子串
    else {
        //完整子串
        Sub.ch = (char *)mal1oc(len * sizeof(char));
        Sub.ch[0..len-1] = s.ch[pos- 1..pos + len- 2];
        Sub.length = len;
    }
    return OK;
} // SubString
```

***

#### 串的块链存储表示

- **定义**
  - 结每个结点可以存放一个字符,也可以存放多个字符
  - 当结点大小大于1时,由于串长不一定是结点大小的整倍数，则链表中的最后一个结点不一定全被串值占满,此时通常补.上**“#”**或其他的非串值字符

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\NI_Z4F97U34@G6CS62()LOE.png" alt="img" style="zoom:67%;" />

- 为了便于进行串的操作,当以链表存储串值时,除头指针外还可附设一个尾指针指示链表中的最后一个结点,并给出当前串的长度。称如此定义的串存储结构为**块链结构**

```c
# define CHUNKSIZE 80			//可由用户定义的块大小.
typedef struct Chunk {
    char ch[CHUNKSIZE] ;
    struct Chunk * next ;
}Chunk;
typedef struct {
    Chunk * head, * tail;		//串的头和尾指针
    int curlen;					//串的当前长度
}LString;
```

- 由于在一般情况下，对串进行操作时，只需要从头向尾顺序扫描即可，则对串值不必建立双向链表。设尾指针的目的是为了便于进行联结操作，但应注意联结时需处理第一个串尾的无效字符。

- **存储密度=**
  串值所占的存储位

  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-

  实际分配的存储位

**不作详细讨论**

***

### 3、3串的模式匹配

#### 求子串位置的定位函数 

- **Index(S, T, pos)**
- 子串的定位操作通常称做**串的模式匹配(其中T称为模式串)**，是各种串处理系统中最重要的操作之一。

```c
int Index(SString S, SString T, int pos){
    int i,j;
    i = pos, j = 1;
    while(i <= S[0] && j <= T[0]){
        if(S[i] == S[j]) {i++ ; j++}
        else{
            i = i - j + 2;
            j = 1
        }
    }
    if(j > T[0]) return i-T[0];
    else return 0;
}
```

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\1.png" style="zoom: 67%;" />

****

#### KMP改进算法

```c
int Index_KMP(SString S, SString T, int pos) {
    //利用模式串T的next函数求T在主串S中第pos个字符之后的位置的
    // KMP算法。 其中,T非空,1≤pos≤StrLength(S)。
    i = pos;
    j = 1;
    while (i <= s[0] && j <= T[0]) {
    if ( j == 0 || s[i] == T[j]) { ++ i; ++j; }	 //继续比较后继字符
    else j = next[j];							//模式串向右移动
	}
    if (j > T[0]) return i - T[0];				 //匹配成功
    else return 0;
} // Index- KMP
```

- 此算法可以在**O(n+m)**的时间数量级上完成串的模式匹配操作。
- 其改进在于:每当一趟匹配过程中出现字符，比较不等时，**不需回溯i指针**，而是利用已经得到的“部分匹配”的结果将模式串向右“滑动”尽可能远的一段距离后,继续进行比较。

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\2.png" style="zoom:67%;" />

- 若令next[i]=k,则next[j]表明当模式中第j个字符与主串中相应字符“失配”时，在模式中需重新和主串中该字符进行比较的字符的位置。由此可引出模式串的next函数的定义:

![3](C:\Users\13793\Desktop\学习笔记\数据结构\3.png)

```c
void get_ next(SString T，int next[ ]) {
    //求模式串T的next函数值并存人数组next。
    i = 1;
    next[1] = 0;
    j = 0;
    while (i < T[0]) {
        if(j == 0 || T[i] == T[j]) { ++i; ++j; next[i] = j; }
        else j = next[j];
    }
}// get. next
```

- 修正值的算法

```c
void get_nextval(SString T, int nextval[ ]) {
    //求模式串T的next函数修正值并存人数组nextval。
    i = 1;
    nextval[1] = 0;
    j = 0;
    while (i < T[0]) {
        if(j == 0 || T[i] == T[j]){ ++i; ++ j; 
            if (T[i] != T[j]) nextval[i] = j;
            e1se nextval[i] = nextval[j] ;
        }
        else j = nextval[j];
    }
} // get_ nextval
```

***

#### 串操作应用







***

## 4、数组和广义表

### 数组顺序存储的表示和实现

- **顺序存储**

```c
typedef struct {
ElemType * base;			//数组元素基址,由InitArray 分配
int dim;					//数组维数
int * bounds;				//数组维界基址,由InitArray分配
int * constants ;			//数组映像函数常量基址,由InitArray分配
} Array;
```

- **基本操作**

````c
Status InitArray (Array &A, int dim,…) ;
//若维数dim和随后的各维长度合法,则构造相应的数组A,并返回OK。
Status DestroyArray(Array &A) ;
// 销毁数组A。
Status Value(Array A, ElemType &e, .;
// A是n维数组,e为元素变量,随后是n个下标值。
//若各下标不超界,则e赋值为所指定的A的元素值,并返回0K。
Status Assign(Array &A, ElemTypee, ..);
// A是n维数组,e为元素变量,随后是n个下标值。.
//若下标不超界,则将e的值赋给所指定的A的元素,并返回OK。
````

**//-----基本操作的算法描述-----**

```c
Status InitArray(Array &A, int dim,...){
    //若维数dim和各维长度合法,则构造相应的数组A,并返回OK
    if (dim < 1 || dim > MAX_ ARRAY_DIM) return ERROR;
    A.dim = dim;
    A.bounds = (int *)malloc(dim * sizeof(int)); 
    if (!A.bounds) exit( OVERFLOW) ;
    //若各维长度合法,则存人A. bounds,并求出A的元素总数elemtotal
    elemtotal = 1 ;
        va_ start(ap, dim) ;
    //ap为va_list类型,是存放变长参数表信息的数组
    for (i=0; i < dim; ++i) {
    	A.bounds[i] = va.arg(ap, int) ;
        if (A.bounds[i]<0) return UNDERFLOW; .
        elemtotal * = A.bounds[i] ;
    }
    va.end(ap) ;
    A.base = (ElemType * )ma11oc( elemtotal * sizeof (ElemType)) ;
    if (!A.base) exit(OVERFLOW) ;
    //求映像函数的常数ci,并存入A.constants[i - 1]，i= 1,...,dim
    A.constants= (int * )mal1oc(dim * sizeof(int));
    if ( ! A.constants) exit( OVERFLOW) ;
    A.constants[dim- 1] = 1; // L= 1,指针的增减以元素的大小为单位
    for ( i = dim- 2; i >= 0; --i)
    	A.constants[i] = A.bounds[i + 1] * A.constants[i + 1] ;
    return OK;
}
```

- **销毁数组**

```c
Status DestroyArray( Array &A) {
    //销毁数组A。
    if (! Abase) return ERROR;
    free(A.base) ; A.base = NULL; .
    if ! (A.bounds) return ERROR;
    free( A. bounds); A.bounds = NULL;
    if ! (A.constants) return ERROR;
    free( A.constants); A.constants = NULL;
    return OK;
}
```

- **求地址**

```c
Status Locate(Array A, va.list ap, int &off) {
    //若ap指示的各下标值合法，则求出该元素在A中相对地址off
    off=0;
    for(i = 0; i < A.dim; ++i){
        ind = va.arg(ap, int) ;
        if (ind < 0 || ind >= A.bounds[i])
        return OVERFLOW;
        off += A.constants[i] * ind;
    }
    return OK;
}
```

- 

```c
Status value(Array A, ElemType &e, ..) {
    // A是n维数组,e 为元素变量,随后是n个下标值。
    //若各下标不超界,则e赋值为所指定的A的元素值,并返回0K.
    va. start(ap, e) ;
    if ((result = Locate(A，ap, off)) <= 0) return result;
    e = *(A.base + off) ;
    return 0K;
}
```

- 

```c
Status Assign(Array &A, ElemTypee, .. {
    // A是n维数组,e为元素变量,随后是n个下标值。
    //若下标不超界,则将e的值赋给所指定的A的元素,并返回0K。
    va start(ap, e);
    if ((result = Locate(A, ap, off)) <= 0) return result;
    *(A. base+ off) = e;
    return OK;
}
```

***

### 矩阵的压缩存储

- 假若值相同的元素或者零元素在矩阵中的分布有一定规律,则我们称此类矩阵为**特殊矩阵**;反之,称为**稀疏矩阵**







------------------

## 5、树和二叉树

### 5、1树的定义和基本术语

- 树(Tree)是n(n≥0)个结点的有限集。
  - 在任意一个非空树中：
    - **有且仅有一个**特定的称为**根(Root)**的结点;
    - 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1,T2,.,Tm,其中每一个集合本身又是一棵树,并且称为根的子树(SubTree)

***

#### 基本操作

- **InitTree( &T) ;**
  操作结果:构造空树T.
- **DestroyTree( &T);**
  初始条件:树T存在。
  操作结果:销毁树T。
- **CreateTree( &T, definition) ;**
  初始条件:definition给出树T的定义。，
  操作结果:按definition构造树T。
- **ClearTree( &T);**
  初始条件:树T存在。
  操作结果:将树T清为空树。
- **TreeEmpty(T);**
  初始条件:树T存在。
  操作结果:若T为空树.则返回TRUE,否则FALSE。
- **TreeDepth(T);**
  初始条件:树T存在。
  操作结果:返回T的深度。
- **Root(T);**
  初始条件:树T存在。
  操作结果:返回T的根。
- **Value(T, cur_e);**
  初始条件:树T存在.cur_e是T中某个结点。
  操作结果:返回cur_ e的值。
- **Assign(T, cur_e, value);**
  初始条件:树T存在,cur_e是T中某个结点。
  操作结果:结点cur_e赋值为value。
- **Parent(T, cur_e);**
  初始条件:树T存在,cur_e是T中某个结点。
  操作结果:若cur_e是T的非根结点,则返回它的双亲,否则函数值为“空”。
- **LeftChild(T, cur_e);**
  初始条件:树T存在,cur_ e是T中某个结点。
  操作结果:若cur_e是T的非叶子结点.则返回它的最左孩子,否则返回“空”。
- **RightSibling(T, cur_e);**
  初始条件:树T存在,cur. e是T中某个结点。
  操作结果:若cur_e有右兄弟,则返回它的右兄弟,否则函数值为“空”。
- **InsertChild(&T. &p, i, c);**
  初始条件:树T存在,p指向T中某个结点.1≤i≤p所指结点的度+ 1.非空树c与T不相交。
  操作结果:插人c为T中P指结点的第i棵子树。
- **DeleteChild(&T, &p, i);**
  初始条件:树T存在.p指向T中某个结点,1≤i≤p指结点的度。
  操作结果:删除T中p所指结点的第i棵子树。
- **TraverseTree(T, Visit());**
  初始条件:树T存在,Visit是对结点操作的应用函数。
  操作结果:按某种次序对T的每个结点调用函数visit()一次且至多一次。一旦visit()失败,则操作失败。

***

- 树的结点包含一个**数据元素**及若干**指向其子树**的分支。
  - 结点拥有的**子树数**称为结点的**度(Degree)**
    - 度为0的结点称为**叶子(Leaf)**或**终端结点**
    - 度不为0的结点称为非终端结点或分支结点。
  - 除根结点之外,分支结点也称为**内部结点**
  - 树的度是**树内各结点的度的最大值**
  - 结点的子树的根称为该结点的**孩子(Child)** ,相应地,该结点称为孩子的**双亲(Parent)**
  - 同一个双亲的孩子之间互称**兄弟(Sibling)**。
  - 结点的祖先是从根到该结点**所经分支上的所有结点**
    - 反之 , 以某结点为根的子树中的任一结点都称为该结点的子孙
- **结点的层次(Level)**
  - 从根开始定义起,根为第一层,根的孩子为第二层。若某结点在第l层,则其子树的根就在第l+1层。其双亲在同一层的结点互为堂兄弟。
  - 树中结点的最大层次称为树的**深度(Depth)或高度**
    如果将树中结点的各子树看成从左至右是有次序的(即不能互换),则称该树为有序树, 否则称为无序树。在有序树中最左边的子树的根称为第一个孩子,最右边的称为最后一个孩子
- **森林(Forest)**是m(m≥0)棵**互不相交的树**的集合。对树中每个结点而言,其子树的C
  集合即为森林。由此,也可以森林和树相互递归的定义来描述树。

***

### 5、2二叉树

- 二叉树(Binary Tree)是另一种树型结构,它的特点是每个结点至多只有两棵子树(即二叉树中不存在度大于2的结点),
- 并且二叉树的子树有左右之分,其次序不能任意颠倒

***

#### 性质

- 在二叉树的第 i 层上至多有**2<sup>i-1</sup>**个结点

- 深度为 k 的二叉树至多有 **2<sup>k</sup>-1**个结点
- 对任何一棵二叉树 T，其**叶子数**为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1

> 一棵深度为 k 且有 **2<sup>k</sup>-1**个结点的二叉树称为**满二叉树**
>
> 由此可引出完全二叉树的定义
>
> 深度为 k 的, 有n个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中**编号从1至n的结点 一 一对应**时，称之为**完全二叉树**
>
> - 显然，这种树的特点是:
>   - 叶子结点只可能在层次最大的两层上出现
>   - 对任一结点，若其右分支下的子孙的最大层次为l,则其左分支下的子孙的最大层次必为l或l+1。
>   - 如图6.4中(c)和(d)不是完全二叉树。

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\4.png" style="zoom:67%;" />

- **完全二叉树的性质**
  - <img src="C:\Users\13793\Desktop\学习笔记\数据结构\}78VPG_IO3AWCNU$DET6RHU.png" alt="img" style="zoom: 50%;" />
  - 如果对一棵有 n 个结点的完全二叉树(其深度为 [log<sub>2</sub>n]+1) 的结点按层序编号(从第1层到第[log<sub>2</sub>n]+1层,每层从左到右),则对任一结点 i ( 1 ≤ i ≤ n ), 有
    - 如果 i = 1,则结点  i  是二叉树的根 ,  无双亲 ;  如果 i > 1,则其双亲  **PARENT(i)**  是结点  [i/2]
    - 如果 2i  > n,  则结点  i  无左孩子 (结点  i  为叶子结点) ;   否则其左孩子 **LCHILD(i)**是结点2i
    - 如果 2i+1 > n,则结点 i 无右孩子 ;   否则其右孩子**RCHILD(i)**是结点  2i + 1

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\8J3]N2MGYW3%XYCX{WLL`53.png" alt="img" style="zoom:67%;" />

***

#### 二叉树存储结构

- **顺序存储**

```c
#define MAX_TREE_SIZE 100						//二义树的最大结点数
typedef TElemType SqBiTree[MAX_TREE_SIZE];		// ()号单元存储根结点
SqBiTree bt;
```

- 按照顺序存储结构的定义, 在此约定, 用一组**地址连续**的存储单元依次**自上而下、自左至右**存储完全二叉树上的结点元素,即将完全二叉树上编号为 i 的结点元素存储在如上定义的一维数组中下标为 i-1 的分量中,图6. 6(a)所示为完全二叉树的顺序存储结构
- 对于一般二叉树，则应将其每个结点与完全二叉树上的结点相对照，存储在一维数组的相应分量中，二叉树的顺序存储结构如图6.6(b)所示，图中以“0”表示不存在此结点.由此可见,这种顺序存储结构仅适用于完全二叉树

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\7.png" style="zoom:67%;" />

***

- **链式存储结构**
  
  ```c
  typedef struct BiTNode{
      TElemType data;
      struct BiTNode * lchild. * rchild; // 左右孩子指针
  }BiTNode. * BiTree;
  ```
  
  - 由二叉树的定义得知,二叉树的结点(如图6. 7(a)所示)由一个数据元素和分别指向其左、右子树的两个分支构成
  - 则表示二叉树的链表中的结点至少包含3个域:  **数据域和左、右指针域**, 如图6. 7(b)所示
  - 有时,为了便于找到结点的双亲，则还可在结点结构中**增加一个指向其双亲结点的指针域**,如图6. 7(c)所示
  - 利用这两种结点结构所得二叉树的存储结构分别称之为二叉链表和三叉链表,如图6.8所示

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\5.png" style="zoom:50%;" />

***

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\6.png" style="zoom: 58%;" />

***

### 5、3遍历二叉树和线索二叉树

#### 遍历二叉树

- 先序遍历二叉树的操作定义为:
  若二叉树为空，则空操作;否则
  - 访问根结点;
  - 先序遍历左子树;
  - 先序遍历右子树
- 中序遍历二叉树的操作定义为:
  若二叉树为空,则空操作;否则
  - 中序遍历左子树;
  - 访问根结点;
  - 中序遍历右子树。
- 后序遍历二叉树的操作定义为:
  若二叉树为空,则空操作;否则
  - 后序遍历左子树;
  - 后序遍历右子树;
  - 访问根结点。

***

- **先序遍历二叉树**

```c
void PreOrderTraversal(BiTree BT){
	if(BT){
        printf("%d",BT->data)
        PreOrderTraversal(SqBiTree BT->lchild);  //  根，左，右
        PreOrderTraversal(SqBiTree BT->rchild);
    }
}
//中序仅需调换位置
void InOrderTraversal(BiTree BT){
	if(BT){
        InOrderTraversal(BiTree BT->lchild);	//	左，根，右
        printf("%d",BT->data);
        InOrderTraversal(BiTree BT->rchild);
    }
}
```

- **堆栈方法**

```c
Status InOrderTraversal(BiTree BT){
    BiTree T;
    T = BT;
    Stack S = InitStack();
    while(T || !StackEmpty(S)){
        if(T){
            Push(S,T);
            T = T->Lchild;
        }	
        else{
            Pop(S,T);
            printf("%d",T->data);
            T = T->Rchild;
        }
    }
    return OK;
}
```

- **先序创建二叉树**

```c
Status CreateBiTree(BiTree &T){
    while(scanf("%d",&ch) != 1){
        if(ch == ' ') T = NULL;
        else{
            if(!(T = (BiTNode* )malloc(sizeof(BiTNode)))) exit(OVERFLOW);
            T->data = ch;						//生成根结点
            CreatBiTree(T->Lchild);				//生成左子树
            CreatBiTree(T->Rchild);				//生成右子树
        }
    }
}
```

***

#### 线索二叉树

- 在 n 个结点的二叉树中必定有 n+1 个空链域，则
  - 试作如下规定:
    - 若结点**有左子树**，则其lchild 域指示其左孩子，否则令lchild 域指示其前驱
    - 若结点**有右子树**，则其rchild 域指示其右孩子，否则令rchild 域指示其后继。
    - 为了避免混淆，尚需改变结点结构，增加两个**标志域**

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\903TZUA39VL`UJK%M1_DM.png" alt="img" style="zoom:67%;" />

- 以这种**结点结构构成的二叉链表**作为二叉树的存储结构，叫做**线索链表**，其中指向**结点前驱和后继**的指针,叫做**线索**
  - 加上线索的二叉树称之为**线索二叉树**

- 图6.11(a)所示为**中序线索二叉树**，与其对应的中序线索链表如图6. 11(b)所示
- 其中实线为指针(指向左、右子树)，虚线为线索(指向前驱和后继)
- 对二叉树以某种次序遍历使其变为线索二叉树的过程叫做**线索化**

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\8.png" style="zoom: 50%;" />

***

- 根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树中最左下的结点。
  - 例如在找结点 ***** 的后继时
    - 首先沿右指针找到其**右子树的根结点** “ - ” 
    - 然后顺其左指针往下直至其**左标志为1**（即指针指向前驱）的结点，即为结点 ***** 的后继，在图中是结点c
  - 反之，在中序线索树中找结点前驱的规律是：
    - 若其左标志为“1",则左链为线索,指示其前驱
    - 否则遍历左子树时最后访问的一个结点(**左子树中最右下的结点**)为其前驱。

- 在后序线索树中找结点后继较复杂些，可分3种情况
  - 若结点x是二叉树的根，则其后继为空
  - 若结点x是其**双亲的右孩子**或是其**双亲的左孩子且其双亲没有右子树**，则其后继即为双亲结点
  - 若结点x是其**双亲的左孩子**,且其双亲有右子树，则其后继为双亲的**右子树上**按后序遍历列出的**第一个结点**

- 例如图6.12所示为后序后继线索二叉树
  - 结点B的后继为结点C，结点C的后继为结点D，结点F的后继为结点G，而结点D的后继为结点E
  - 可见,在后序线索化树上找后继时需知道结点双亲，即需带标志域的三叉链表作存储结构。

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\YKE1[V@IJL1Z}XV9YKNIJ.png" alt="img" style="zoom:50%;" />

***

**二叉树的线索存储表示**

```c
typedef enum PointerTag { Link, Thread }; 	 	// Link == 0:指针,Thread == 1:线索
typedef struct BiThrNode {
    TElemType data;
    struct BiThrNode * lchild, * rchild; 		// 左右孩子指针
    PointerTag LTag, RTag;						//左右标志
} BiThrNode，* BiThrTree;
```

- 为方便起见，仿照线性表的存储结构，在二叉树的线索链表上也添加一个头结点
  - 令其lchild域的指针指向二叉树的根结点，其rchild域的指针指向中序遍历时访问的最后一个结点
  - 反之，令二叉树中序序列中的第一个结点的 lchild 域指针和最后一个结点rchild域的指针均指向头结点。
  - 这好比为二叉树建立了一个双向线索链表，既可从第一个结点起顺后继进行遍历，也可从最后一个结点起顺前驱进行遍历(如图6. 11(b)所示)。

***

**中序遍历双向链表二叉树**

```c
Status InOrderTraverse_Thr(BiThrTree T){
    //T指向头结点.头结点的左链1child指向根结点,可参见线索化算法。
    //中序遍历二叉线索树T的非递归算法,对每个数据元素调用函数Visit。
    p = T->lchild;											//p指向根结点
    while (p != T) {										//空树或遍历结束时.p == T
        while (p->LTag == Link) 
            p = p->lchild;
        if (!Visit(p->data)) return ERROR; 				// 访问其左子树为空的结点
        while(p->RTag == Thread && p->rchild != T) {
        	p = p->rchi1d; 
            Visit(p->data);								//访问后继结点
        }													
        p =p->rchild;
    }
    return OK;
} // InOrderTraverse_Thr
```

***

**二叉树的线索化**

- 为了记下遍历过程中访问结点的先后关系，附设一个指针pre始终指向刚刚访问过的结点
- 若指针p指向当前访问的结点，则pre指向它的前驱。
- 由此可得中序遍历建立中序线索化链表的算法如所示

```c
Status InOrderThreading( BiThrTree &Thrt, BiThrTree T) {
    //中序遍历二叉树T.并将其中序线索化,Thrt指向头结点。
    if(!(Thrt = (BiThrTree)malloc(sizeof(BiThrNode)))) exit(OVERFLOW) ;
    Thrt->LTag = Link;
    Thrt->RTag = Thread;					//建头结点
    Thrt->rchild = Thrt; 					//右指针回指
    if (!T) 
        Thrt->lchild = Thrt;			//若二叉树空.则左指针回指
    else {
        Thrt->lchild = T;
        pre = Thrt;
        InThreading(T);							//中序遍历进行中序线索化
        pre->rchild = Thrt; pre->RTag = Thread; // 最后一个结点线索化
        Thrt->rchild = pre;
    }
    return OK;
} // InOrderThreading
void InThreading(BiThrTree p) {
    if (p) {
        InThreading(p->lchild); 			// 左子树线索化
        if (!p->lchild) {
            p->LTag = Thread; 
            p->lchild = pre; 
        } 									//前驱线索
        if (!pre->rchild) {
            pre->RTag = Thread; 
            pre->rchild = p; 
        }									//后继线索
        pre = p;							// 保持pre指向p的前驱
        InThreading(p->rchild); 			// 右子树线索化
    }
} // InThreading
```

***

### 5、4树和森林

#### 树的存储结构

- 双亲表示法

  ```c
  #define MAX_TREE_SIZE 100
  typedef struct PTNode { // 结点结构
      TElemType data; 
  	int parent; 		// 双亲位置域
  }PTNode;
  typedef struct {		//树结构
      PTNode nodes[MAX_TREE.SIZE];
      int r,n;			//根的位置和结点数
  }PTree;
  ```

  <img src="C:\Users\13793\Desktop\学习笔记\数据结构\L`AAI_P7OW2OY0XH(US`)J.png" alt="img" style="zoom:50%;" />

***

- **孩子表示法**

  ```c
  typedef struct CTNode {				//孩子结点
      int chi1d; 
      struct CTNode * next;
  }*ChildPtr ;
  typedef struct{
      TE1emType data;
      ChildPtr firstchild;			//孩子链表头指针
  } CTBox ;
  typedef struct {
      CTBox nodes[ MAX_TREE_SIZE] ;
      int n，r;						//结点数和根的位置 ;
  }CTree ;
  ```

  ![](C:\Users\13793\Desktop\学习笔记\数据结构\9.png)

***

- **孩子兄弟表示法**

  - 又称二叉树表示法,或二叉链表表示法。即以二叉链表作树的存储结构
  - 链表中结点的两个链域分别指向该结点的**第一个孩子结点**和**下一个兄弟结点**

  ```c
  typedef struct CSNode {
      ElemType data;
      struct CSNode *firstchild, *nextsibling;
  }CSNode，*CSTree;
  ```

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\10.png" style="zoom:50%;" />

***

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\11.png" style="zoom:50%;" />

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\12.png" style="zoom:50%;" />

***

#### 森林与二叉树的转换

- 任何一棵和树对应的二叉树，其右子树必定为空
- 若把森林中第二棵树的根结点看成是第一棵树的根结点的兄弟，则同样可导出森林和二叉树的对应关系

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\13.png" style="zoom:50%;" />

***

![img](C:\Users\13793\Desktop\学习笔记\数据结构\}M48J]0_ZS04[Y]X[8NGE2.png)

- 先序遍历森林
  若森林非空,则可按下述规则遍历之:
  - 访问森林中第一棵树的根结点;
  - 先序遍历第一棵树中根结点的子树森林;
  - 先序遍历除去第一棵树之后剩余的树构成的森林。
- 中序遍历森林
  若森林非空,则可按下述规则遍历之:
  - 中序遍历森林中第一棵树的根结点的子树森林;
  - 访问第--棵树的根结点;
  - 中序遍历除去第一棵树之后剩余的树构成的森林。
- 若对**图6.17**中森林进行先序遍历和中序遍历,则分别得到森林的
  - 先序序列为
    A B C D E F G H I J
  - 中序序列为
    B C D A F E H J I G 

***

### 5、5赫夫曼树

#### 最优二叉树（赫夫曼树）

- 从树中一个结点到另一个结点之间的分支构成这两个结点之间的**路径**，路径上的分支数目称做**路径长度**

- 树的路径长度是从**树根到每一结点**的路径长度之和

  - 若将上述概念推广到一般情况,考虑带权的结点
  - 结点的带权路径长度为从该结点到树根之间的**路径长度与结点上权的乘积**
  - 树的带权路径长度为树中所有叶子结点的带权路径长度之和,通常记作
  - <img src="C:\Users\13793\Desktop\学习笔记\数据结构\14.png" style="zoom:50%;" />

- #### **构造赫夫曼树**

![](C:\Users\13793\Desktop\学习笔记\数据结构\15.png)

***

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\RBMT6%$}83YKEI0O9B[T[DB.png" alt="img" style="zoom: 50%;" />

***

**赫夫曼编码**

- 若要设计长短不等的编码，则必须是任一个字符的编码都不是另一个字符的编码的前缀，这种编码称做**前缀编码**
- 可以利用二叉树来设计二进制的前缀编码。
  - 假设有一棵如图6.25所示的二叉树，其4个叶子结点分别表示A、B、C、D这4个字符，且约定左分支表示字符'0' ,右分支表示字符'1' 
  - 可以从**根结点到叶子结点的路径上分支字符组成的字符串**作为该叶子结点字符的编码
  - 如由图6. 25所得A、B、C、D

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\16.png" style="zoom:67%;" />

***

- 由于在构成赫夫曼树之后，为求编码需从叶子结点出发走一条从叶子到根的路径
- 而为译码需从根出发走一条从根到叶子的路径
- 则对每个结点而言，既需知双亲的信息，又需知孩子结点的信息，由此，设定下述存储结构:

```c
//-----赫夫曼树和赫夫曼编码的存储表示- - -- -
typedef struct {
    unsigned int weight;
    unsigned int parent, lchild, rchild;
}HTNode，* HuffmanTree;
//动态分配数组存储赫夫曼树
typedef char* *HuffmanCode;//动态分配数组存储赫夫曼编码表
```

- 求赫夫曼编码

```c
void HuffmanCoding(HuffmanTree &HT, HuffmanCode &HC，int *w, int n) {
    //w存放n个字符的权值(均>0),构造赫夫曼树HT,并求出n个字符的赫夫曼编码HC
    if (n <= 1) return;
    m = 2 * n - 1;
    HT = (HuffmanTree)malloc((m + 1) * sizeof(HTNode));			// 0号单元未用.
    for(p = HT,i = 1;i <= n; ++i, ++p, ++w)  
        *P = {*w,0,0,0};
    for(;i <= m; ++i, ++p) 
        *p = {0,0,0,0};
    for (i = n + 1; i <= m; ++i) { 		// 建赫夫曼树
        //在HT[1..i- 1]选择parent为0且weight最小的两个结点,其序号分别为s1和s2。
        Select(HT, i - 1, s1, s2);
        HT[s1].parent = i; HT[s2]. parent = i;
        Hr[i].1child = s1; HT[i]. rchild = s2;
        hT[i].weight = HT[s1].weight + HhtT[s2].weight;
    }
    //---从叶子到根逆向求每个字符的赫夫曼编码-一一
    HC = (HuffmanCode)malloc((n + 1) * sizeof(char *)); // 分配n个字符编码的头指针向量
    cd = (char *)mal1oc(n * sizeof(char));	//分配求编码的工作空间
    cd[n-1] = "\0";							//编码结束符。
    for (i = 1; i <= n; ++i) {				//逐个字符求赫夫曼编码
        start = n-1;							//编码结束符位置
        for (c = i, f = ht[i].parent; f != 0; c = f, f = HT[f].parent){
            //从叶子到根逆向求编码
            if (HT[f].1child == c) 
                cd[--start] = "0";
            else 
                cd[--start] = "1";
            HC[i] = (char * )malloc((n - start) *sizeof(char)); //为第i个字符编码分配空间
            strcpy(HC[i]，&cd[start]);		//从cd复制编码(串)到HC
            free(cd) ;						//释放工作空间
    }
} // HuffanCoding
```

- **从根遍历**

```c
    //------无栈非递归遍 历赫夫曼树,求赫夫曼编码
    HC = ( HuffmanCode)malloc((n + 1) *sizeof(char *));
    P = m;
    cdlen = 0;
    for (i = 1; i <= m; ++ i) HT[i].weight = 0; //遍历赫夫曼树时用作结点状态标志
    while (p){
        if (HT[p]. weight==0) {			//向左
            HT[p]. weight = 1;
            if (HT[p]. 1child != 0) {p = HT[p].lchild; cd[cdlen++] = "0"; }
            else if(HT[p].rchild == 0) { 	// 登记叶子结点的字符的编码
                HC[p] = (char *)malloc((cdlen + 1) * sizeof (char));
                cd[cdlen] = "\0"; strcpy(HC[p], cd);		//复制编码(串)
        }
        else if(HT[p].weight== 1) {	//向右
        HT[p].weight = 2;
        if (HT[p]. rchild != 0) {
            p = HT[p].rchild; 
            cd[cdlen++] = "1"; }
        }
        else{					// HT[p].weight= = 2,退回
            HT[p]. weight = 0; p = HT[p]. parent; --cdlen; // 退到父结点,编码长度减1
        }//else
	} // While
```



***

## 6、图

### 6、1图的定义和术语

- **基本操作**
  - **CreateGraph( &G,V, VR) ;** 
    初始条件:V是图的顶点集,VR是图中弧的集合。
    操作结果:按V和VR的定义构造图G.
  - **DestroyGraph(&G) ;**
    初始条件:图G存在。
    操作结果:销毁图G。
  - **LocateVex(G, u);** 
    初始条件:图G存在,u和G中顶点有相同特征。
    操作结果:若G中存在顶点u,则返回该顶点在图中位置;否则返回其他信息。
  - **GetVex(G, v);**
    初始条件:图G存在,v是G中某个顶点。
    操作结果:返回v的值。
  - **PutVex(&G, v, value)** ; 
    初始条件:图G存在,v是G中某个顶点。
    操作结果;对v赋值value.
  - **FirstAdjVex(G，v);**
    初始条件:图G存在,v是G中某个顶点。
    操作结果:返回v的第一一个邻接顶点。若顶点在G中没有邻接顶点,则返回“空”。
  - **NextAdjVex(G，v, w); ;**
    初始条件:图G存在,v是G中某个顶点,w是v的邻接顶点。
    操作结果:返回v的(相对于w的)下一个邻接顶点。若w是v的最后一个邻接点,则返
    回“空”。
  - **InsertVex(&G, v);**
    初始条件:图G存在,v和图中顶点有相同特征。
    操作结果:在图G中增添新顶点v。
  - **DeleteVex(&G, v);**
    初始条件:图G存在,v是G中某个顶点。
    操作结果:删除G中顶点v及其相关的弧。
  - **InsertArc(&G, v, w);**
    初始条件:图G存在,v和w是G中两个顶点。
    操作结果:在G中增添弧< <v,w> ,若G是无向的,则还增添对称弧< <w,v> >。
  - **DeleteArc(&G, v, w);**
    初始条件:图G存在,v和w是G中两个顶点。
    操作结果:在G中删除弧<v,w> ,若G是无向的,则还删除对称弧< <w,v>。
  - **DFSTraverse(G, Visit());**
    初始条件:图G存在,Visit是顶点的应用函数。
    操作结果:对图进行深度优先遍历。在遍历过程中对每个顶点调用函数Visit-次
    且仅- -次。一旦visit()失败,则操作失败。
  - **BFSTraverse(G, Visit());**
    初始条件:图G存在,Visit是顶点的应用函数。
    操作结果:对图进行广度优先遍历。在遍历过程中对每个顶点调用函数Visit-次
    且仅一次。一旦visit()失败,则操作失败。

***

- **定义**
  - 在图中的**数据元素**通常称做**顶点(Vertex)**，V是顶点的**有穷非空集合**
  - VR是两个顶点之间的关系的集合。若<v,w>∈VR ,则<v,w>表示从v到w的一条**弧(Arc)**，且称v为弧尾(Tail)或初始点(Initial node)，称w为弧头(Head)或终端点( Terminal node), 此时的图称为**有向图(Digraph)**。
  - 若<v,w>∈VR必有<w,v>∈VR,即VR是对称的,则以无序对(v,w)代替这两个有序对，表示v和w之间的一条边(Edge),此时的图称为**无向图(Undigraph)**
- n表示顶点数目，e表示边或弧的数目
- 对于无向图，e的取值范围是0到n(n-1)/2
  - 有n(n-1)/2条边的无向图称为**完全图**(Completedgraph)
- 对于有向图,e的取值范围是0到n(n-1)
  - 具有n(n-1)条弧的有向图称为**有向完全图**
- 有很少条边或弧(如**e<nlogn**)的图称为**稀疏图**(Sparsegraph)，反之称为**稠密图**(Densegraph)

对于无向图G=(V,{E}),如果边(v,v')∈E,则称顶点v和u'互为邻接点(Adja-cent),即v和v'相邻接。边(v,v' )依附(Incident)于顶点v和o' ,或者说(U,v' )和顶点v和v'相关联。顶点v的度(Degree)是和v相关联的边的数目,记为TD(V)。例如,G2中
顶点V3的度是3。对于有向图G=(V,{A}),如果弧<v,v')∈A,则称顶点o邻接到顶点v' ,顶点v'邻接自顶点v。弧<v,v' >和顶点v,v'相关联。以顶点v为头的弧的数目称为V的入度(InDegree),记为ID(v);以v为尾的弧的数目称为v的出度(Outdegree),记为OD(v);顶点v的度为TD(v)=ID(v)+OD(v)。例如,图G1中顶点V1的人度ID(u)=1,出度OD(u1)=2,度TD(u1)= ID(u])+OD(u])=3。 一-般地，如果顶点V;的度记为TD(v;),那么一个有n个顶点,e条边或弧的图,满足如下关系<img src="C:\Users\13793\Desktop\学习笔记\数据结构\17.png" style="zoom:50%;" />

![](C:\Users\13793\Desktop\学习笔记\数据结构\18.png)

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\9NGZQ7OYA2P_3LQRE(HV)DU.png" alt="img" style="zoom:50%;" />

***

- **强连通图**
  - 从v<sub>i</sub>到v<sub>j</sub>都有路径的图
  - 有向图的极大强连通子图称为
- **生成树**
  - 极小的连通子图
  - 在生成树上添加一条边，必定构成一个环
- 如果一个有向图恰有**一个顶点的入度为0**,**其余顶点的入度均为1**，则是一棵有向树。
- 一个有向图的生成森林由若干棵有向树组成,含有图中全部顶点,但只有足以构成若干棵不相交的有向树的弧

***

### 6、2图的存储结构

#### 数组表示法

```c
//-----图的数组(邻接矩阵)存储表示一-- --
#define INEINITY INT.MAX						//最大值∞
#define MAX_VERTEX_NUM 20						//最大顶点个数
typedef enum {DG, DN, UDG, UDN} GraphKind;		//{有向图,有向网,无向图,无向网}
typedef struct ArcCell {
    VRType adj; 								//VRType 是顶点关系类型。对无权图,用1或0
    											//表示相邻否;对带权图,则为权值类型。
    InfoType * info; 							//该弧相关信息的指针
}ArcCell, AdjMatrix[ MAX_VERTEX_NUM][ MAX_VERTEX_NUM];
typedef struct {
    VertexType vexs[ MAX_ VERTEX. NUM];			//顶点向量
    AdjMatrix arcs;								//邻接矩阵
    int vexnum, arcnum;							//图的当前顶点数和弧数
    GraphKind kind;								//图的种类标志
}MGraph;
```

- **构造图**

```c
Status CreateUDN(MGraph &G) {
    //采用数组(邻接矩阵)表示法,构造无向网G。
    scanf( &G.vexnum，&G.arcnum, &IncInfo) ;
    //IncInfo为0则各弧不含其他信息
    for (i = 0; i < G.vexnum; ++ i ) scanf (&G.vexs[i]); 	// 构造顶点向量
    for (i = 0; i < G.vexnum; ++ i )						//初始化邻接矩阵
    	for (j=0; j < G.vexnum; ++j ) G.arcs[i][j] = {INEINITY, NULL}; //{adj , info}
    for (k=0; k<G. arcnum; ++k ) {
        //构造邻接矩阵
        scanf(&vl, &v2, &w);							//输人一条边依附的顶点及权值
        i = LocateVex(G, v1); j = LocateVex(G, v2); 	//确定vl和v2在G中位置
        G.arcs[i][j].adj = w;							// 弧<v1,v2>的权值
        if (IncInfo) Input( *G.arcs[i][j].info);		// 若弧含有相关信息,则输人
        G.arcs[j][i] = G.arcs[i][j];					//置<v1,v2>的对称弧<v2,v1>
    }
	return OK;
} // CreateUDN
```

***

#### 邻接表

- 邻接表(Adjacency List)是图的一种链式存储结构
  - 在邻接表中，对图中每个顶点建立一个单链表，第 i 个单链表中的结点表示依附于顶点 $v_i$的边(对有向图是以顶点 v<sub>i</sub> 为尾的弧)
  - 每个结点由3个域组成
    - 其中**邻接点域 (adjvex)** 指示与顶点 v<sub>i</sub> 邻接的点在**图中的位置**
    - **链域(nextarc)**指示下一条边或弧的结点
    - **数据域(info)**存储和边或弧相关的信息，如权值等
  - 每个链表上附设一个表头结点。
    - 在表头结点中，除了设有**链域 (firstarc)** 指向链表中第一个结点之外
    - 还设有存储顶点 $v_i$ 的名或其他有关信息的数据域(data)

![](C:\Users\13793\Desktop\学习笔记\数据结构\19.png)

```c
//-----图的邻接表存储表示-----
#define MAX_VERTEX_NUM 20
typedef struct ArcNode{
    int adjvex;					//该弧所指向的顶点的位置
    struct ArcNode *nextarc ;	//指向下一条弧的指针
    InfoType *info;				//该弧相关信息的指针
} ArcNode;
typedef struct VNode{
    VertexType data;			//顶点信息
    ArcNode *firstarc;			//指向第一条依附该顶点的弧的指针
}VNode, AdjList[MAX_VERTEX_NUM];
typedef struct {
    AdjList vertices;
    int vexnum，arcnum;			//图的当前顶点数和弧数
    int kind;					//图的种类标志
} ALGraph;
```

- 若无向图中有n个顶点、e条边，则它的邻接表需**n个头结点和2e个表结点**
- 显然，在边稀疏 $e\ll\frac{\displaystyle n(n-1)}{\displaystyle 2}$ 的情况下，用**邻接表**表示图**比邻接矩阵节省存储空间**，当和边相关的信息较多时更是如此。

***

#### 十字链表

- 十字链表(OrthogonalList)是有向图的另一种链式存储结构
  - 可以看成是将有向图的**邻接表和逆邻接表结合起来**得到的一种链表。在十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点。这些结点的结构如下所示:

![img](C:\Users\13793\Desktop\学习笔记\数据结构\}1XOED_KB0QKBRD9SJ_X90.png)

- 在弧结点中有5个域
  - 其中**尾域(tailvex)和头域(headvex)**分别指示弧尾和弧头这**两个顶点在图中的位置**
  - **链域hlink**指向**弧头相同的下一条弧**，而**链域tlink**指向**弧尾相同的下一条弧**，**info**域指向该弧的**相关信息**
  - 弧头相同的弧在同一链表上，弧尾相同的弧也在同一链表上
  - 它们的头结点即为**顶点结点，**它由3个域组成：其中data域存储和顶点相关的信息，如顶点的名称等
  - **firstin和firstout为两个链域**,分别指向以该顶点为**弧头或弧尾的第一个弧结点**

```c
//-----有向图的十字链表存储表示-----
#define MAX_VERTEX_NUM 20
typedef struct ArcBox{
    int tailvex, headvex; 				 //该弧的尾和头顶点的位置
    struct ArcBox *hlink，*tlink;		//分别为弧头相同和弧尾相同的弧的链域
    InfoType *info;						//该弧相关信息的指针
} ArcBox;
typedef struct VexNode {
    VertexType data;
    ArcBox * firstin, *firstout;		//分别指向该顶点第--条人弧和出弧
} VexNode;
typedef struct {
    VexNode xlist[MAX_VERTEX_NUM]; 	//表头向量
    int vexnum, arcnum ;				//有向图的当前顶点数和弧数
}OLGraph;
```

- **创建链表**

```c
Status CreateDG(OLGraph &G) {
    //采用十字链表存储表示,构造有向图G(G.kind = DG)。
    scanf(&G.vexnum, &G.arcnum, &IncInfo) ;				// IncInfo为0则各弧不含其他信息
    for (i = 0; i < G.vexcnum; ++ i) {						//构造表头向量
        scanf(& G.xlist[i].data);							//输人顶点值
        G.xlist[i].firstin = NULL; G.xlist[i].firstout = NULL; // 初始化指针
    }
    for (k = 0; k < G.arcnum; ++ k) {						//输人各弧并构造十字链表
        scanf(&v1, &v2);									//输人一条弧的始点和终点
        i = LocateVex(G, v1); j = LocateVex(G, v2);			//确定v1和v2在G中位置
        p = (ArcBox *) malloc (sizeof(ArcBox));				//假定有足够空间.
        *p = {i, j, G.xlist[j].firstin, G.xlist[i].firstout, NULL} // 对弧结点赋值
        // {tailvex, headvex, hlink, tlink, info}
        G.xlist[j].firstin = G.xlist[i].firstout = p;		//完成在入弧和出弧链头的插人
		if(IncInfo) Input(*p->info);
    }
    return OK;
}
```

***

###  6、3图的遍历

- 和树的遍历类似，在此，我们希望从图中**某一顶点出发**访遍图中其余顶点，且使**每一个顶点仅被访问一次**
- 这一过程就叫做图的遍历(Traversing Graph）
- 图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。

#### 深度优先搜索(DFS)

- 类似于树的**先根遍历**
- 假设初始状态是图中所有顶点未曾被访问，则深度优先搜索可从图中某个顶点v出发，访问此顶点
- 然后依次从v的**未被访问的邻接点出发深度优先遍历图**，直至图中所有和v有**路径相通的顶点**都被访问到
- 若此时图中尚有顶点未被访问，则另**选图中一个未曾被访问的顶点**作起始点，重复上述过程，直至图中所有顶点都被访问到为止

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\20.png" style="zoom:50%;" />

- 假设从顶点V1出发进行搜索，在访问了顶点V1之后，选择邻接点V2。因为V2未曾访问，
  - 则从V2出发进行搜索。依次类推,接着从V4、V8、V5出发进行搜索
  - 在访问了V5之后，由于V5的邻接点都已被访问,则搜索回到V8。由于同样的理由,搜索继续回到V4，V2直至V1
  - 此时由于V1的另一个邻接点未被访问,则搜索又从V1到V3,再继续进行下去。由此，得到的顶点访问序列为:
    V1$\to$ V2→ V4→ V8→ V5→ V3→V6→ V7

```c
Boolean visited[MAX];				//访向标志数组
Status (*VisitFunc)(int v); 		//函数变量
void DFSTraverse(Graph G, Status (*Visit)(int v)) {	//对图G作深度优先遍历。
    VisitFunc = Visit;						//使用全局变量VisitFunc,使DFS不必设函数指针参数
    for (v = 0; v < G.vexmum; ++ v) visited[v] = FALSE; // 访问标志数组初始化
    for (v = 0; v < G.vexnum; ++ v)
    	if (!visited[v]) DFS(G, v); 	// 对尚未访问的顶点调用DFS
}
void DFS(Graph G, int v) {				//从第v个顶点出发递归地深度优先遍历图G。
    visited[v] = TRUE; VisitFunc(v); 	// 访问第v个顶点
    for ( w = FirstAdjVex(G, v); w >= 0; w = NextAdjVex(G, v, w) )
    	if (!visited[w]) DFS(G, w); 	// 对v的尚未访问的邻接顶点w递归调用DFS
}
```

***

#### 广度优先搜索

- 图G4进行广度优先搜索遍历的过程如图7. 13(c)所示
- 首先访问V1的邻接点V2和V3
- 然后依次访问V2的邻接点V4和V5及V3的邻接点V6和V7,最后访问V4的邻接点V8
- 由于这些顶点的邻接点均已被访问,并且图中所有顶点都被访问,由此完成了图的遍历。得到的顶点访问序列为

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\SB72]P_4AWI}EHRH{BF]HX4.png" alt="img" style="zoom:50%;" />

```c
void BFSTraverse(Graph G, Status (*Visit)(int v)) {
//按广度优先非递归遍历图G。使用辅助队列Q和访问标志数组visited。
    for (v = 0; v < G.vexnum; ++ v) 
        visited[v] = FALSE;
    InitQueue(Q) ;			 //置空的辅助队列Q
    for ( v = 0; v < G.vexnum; ++ v)
        if (!visited[v]){		// v尚未访问
            visited[v] = TRUE; Visit(v);
            EnQueue(Q, v) ; 		//v入队列
            while (!QueueEmpty(Q)) {
                DeQueue(Q, u);			//队头元素出队并置为u
                for ( w = FirstAdjVex(G, u); w >= 0; w = NextAdjVex(G, u, w))
                    if (!Visited[w]) { 	//w为u的尚未访问的邻接顶点
                        Visited[w] = TRUE;	
                        Visit(w);
                        EnQueue(Q, W);
                     } //if
        	} // while
    	}// if
} // BFSTraverse
```

***

### 6、4图的连通性

- 下面先介绍**普里姆算法**。
  - 假设$N=(V，{E})$是连通网，$TE$是$N$上最小生成树中边的集合。
  
  - 算法从 $U=\{u_0\}\;(u\in V),TE=\{\}$ 开始，重复执行下述操作:
    - 在所有 $u∈U ，v\in(V-U)$的边 $(u,v)∈E$ 中找一条代价最小的边 $(u,v)$并入集合 $TE$
    - 同时 $v_0$ 并人U，直至 $U = V $为止
    - 此时$TE$中必有$n—1$条边，则$T=(V，{TE})$为N的最小生成树
    
  - 为实现这个算法需附设一个辅助数组 $closedge$ ，以记录**从$U$到$V一U$具有最小代价的边**。
  
  - 对每个顶点 $v_i∈V一U$，在辅助数组中存在一个相应分量 $\rm closedge[i-1]$，它包括两个域，其中lowcost存储该边上的权。显然，
  
    $\rm closedge[i-1].lowcost= Min\{cost(u,v_i)|u\in U\}$ ，其中**$cost(u,v)$表示赋给$u,v$边上的权**，vex域存放该边依附在U中的顶点

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\VULYJ2[FK6XS6UY3RJMU[X.png" alt="img" style="zoom:67%;" />

```c
#include <stdio.h>
#include <stdlib.h>
#define VertexType int
#define VRType int
#define MAX_VERtEX_NUM 20
#define InfoType char   
#define INFINITY 65535
typedef struct {
    VRType adj;                             //对于无权图，用 1 或 0 表示是否相邻；对于带权图，直接为权值。
    InfoType * info;                        //弧额外含有的信息指针
}ArcCell,AdjMatrix[MAX_VERtEX_NUM][MAX_VERtEX_NUM];

typedef struct {
    VertexType vexs[MAX_VERtEX_NUM];        //存储图中顶点数据
    AdjMatrix arcs;                         //二维数组，记录顶点之间的关系
    int vexnum,arcnum;                      //记录图的顶点数和弧（边）数
}MGraph;

//根据顶点本身数据，判断出顶点在二维数组中的位置
int LocateVex(MGraph G,VertexType v){
    int i = 0;
    //遍历一维数组，找到变量v
    for (; i<G.vexnum; i++) {
        if (G.vexs[i] == v) {
            return i;
        }
    }
    return -1;
}

//构造无向网
void CreateUDN(MGraph* G){
    scanf("%d,%d",&(G->vexnum),&(G->arcnum));
    for (int i = 0; i < G->vexnum; i++) {
        scanf("%d",&(G->vexs[i]));
    }
    for (int i = 0; i < G->vexnum; i++) {		//初始化二维数组
        for (int j  =0; j < G->vexnum; j++) {
            G->arcs[i][j].adj = INFINITY;
            G->arcs[i][j].info = NULL;
        }
    }
    for (int i = 0; i < G->arcnum; i++) {		//每条边赋权值
        int v1,v2,w;
        scanf("%d,%d,%d",&v1,&v2,&w);
        int m = LocateVex(*G, v1);
        int n = LocateVex(*G, v2);
        if (m == -1 ||n == -1) {
            printf("no this vertex\n");
            return;
        }
        G->arcs[n][m].adj = w;
        G->arcs[m][n].adj = w;
    }
}

//辅助数组，用于每次筛选出权值最小的边的邻接点
typedef struct {
    VertexType adjvex;		//记录权值最小的边的起始点
    VRType lowcost;			//记录该边的权值
}closedge[MAX_VERtEX_NUM];
closedge theclose;			//创建一个全局数组，因为每个函数中都会使用到

//在辅助数组中找出权值最小的边的数组下标，就可以间接找到此边的终点顶点。
int minimun(MGraph G, closedge close){
    int min = INFINITY;
    int min_i = -1;
    for (int i = 0; i < G.vexnum; i++) {
        //权值为0，说明顶点已经归入最小生成树中；然后每次和min变量进行比较，最后找出最小的。
        if (close[i].lowcost > 0 && close[i].lowcost < min) {
            min = close[i].lowcost;
            min_i = i;
        }
    }
    //返回最小权值所在的数组下标
    return min_i;
}

//普里姆算法函数，G为无向网，u为在网中选择的任意顶点作为起始点
void miniSpanTreePrim(MGraph G,VertexType u){
    //找到该起始点在顶点数组中的位置下标
    int k = LocateVex(G, u);
    //首先将与该起始点相关的所有边的信息：边的起始点和权值，存入辅助数组中相应的位置，例如（1，2）边，adjvex为0，lowcost为6，存入theclose[1]中，辅助数组的下标表示该边的顶点2
    for (int i = 0; i < G.vexnum; i++) {
        if (i != k) {
            theclose[i].adjvex = k;
            theclose[i].lowcost = G.arcs[k][i].adj;
        }
    }
    //由于起始点已经归为最小生成树，所以辅助数组对应位置的权值为0，这样，遍历时就不会被选中
    theclose[k].lowcost = 0;
    //选择下一个点，并更新辅助数组中的信息
    for (int i = 1; i < G.vexnum; i++) {
        //找出权值最小的边所在数组下标
        k = minimun(G, theclose);
        //输出选择的路径
        printf("v%d v%d\n",G.vexs[theclose[k].adjvex],G.vexs[k]);
        //归入最小生成树的顶点的辅助数组中的权值设为0
        theclose[k].lowcost=0;
        //信息辅助数组中存储的信息，由于此时树中新加入了一个顶点，需要判断，由此顶点出发，到达其它各顶点的权值是否比之前记录的权值还要小，如果还小，则更新
        for (int j = 0; j < G.vexnum; j++) {
            if (G.arcs[k][j].adj < theclose[j].lowcost) {
                theclose[j].adjvex = k;
                theclose[j].lowcost = G.arcs[k][j].adj;
            }
        }
    }
    printf("\n");
}

int main(){
    MGraph G;
    CreateUDN(&G);
    miniSpanTreePrim(G, 1);
}
```

- 普里姆算法的运行效率只与连通网中包含的顶点数相关，而和网所含的边数无关。所以普里姆算法适合于解决边稠密的网，该算法运行的时间复杂度为：O(n2)
- 如果连通网中所含边的绸密度不高，则建议使用克鲁斯卡尔算法求最小生成树。

***

- **克鲁斯卡尔算法**

  - 克鲁斯卡尔算法从另一途径求网的最小生成树。
  - 假设连通网**N=(V，{E})**，则令最小生成树的初始状态为只有n个顶点而无边的非连通图T=(V，{})，图中每个顶点自成一个连通分量。
  - 在E中**选择代价最小的边**，若该边依附的顶点落在T中不同的连通分量上，则将此边加人到T中，否则舍去此边而选择下一条代价最小的边。
  - 依次类推，直至T中所有顶点都在同一连通分量上

  <img src="C:\Users\13793\Desktop\学习笔记\数据结构\image-20200713091253186.png" alt="image-20200713091253186" style="zoom:60%;" />

  - 具体思路是：将所有边按照权值的大小进行升序排序，然后从小到大一一判断，条件为：

    - 如果这个边不会与之前选择的所有边组成回路，就可以作为最小生成树的一部分；
    - 反之，舍去。直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。
    - 筛选出来的边和所有的顶点构成此连通网的最小生成树。

    > 判断是否会产生回路的方法为：在初始状态下给每个顶点赋予不同的标记，对于遍历过程的每条边，其都有两个顶点，判断这两个顶点的标记**是否一致**，如果一致，说明它们本身就处在一棵树中，如果继续连接就会产生回路；如果不一致，说明它们之间还没有任何关系，可以连接。

  ```c
  #include "stdio.h"
  #include "stdlib.h"
  #define MAX_VERtEX_NUM 20
  #define VertexType int
  typedef struct edge{
      VertexType initial;
      VertexType end;
      VertexType weight;
  }edge[MAX_VERtEX_NUM];
  //定义辅助数组
  typedef struct {
      VertexType value;//顶点数据
      int sign;//每个顶点所属的集合
  }assist[MAX_VERtEX_NUM];
  assist assists;
  //qsort排序函数中使用，使edges结构体中的边按照权值大小升序排序
  int cmp(const void *a,const void*b){
      return  ((struct edge*)a)->weight-((struct edge*)b)->weight;
  }
  //初始化连通网
  void CreateUDN(edge *edges,int *vexnum,int *arcnum){
      printf("输入连通网的边数：\n");
      scanf("%d %d",&(*vexnum),&(*arcnum));
      printf("输入连通网的顶点：\n");
      for (int i=0; i<(*vexnum); i++) {
          scanf("%d",&(assists[i].value));
          assists[i].sign=i;
      }
      printf("输入各边的起始点和终点及权重：\n");
      for (int i=0 ; i<(*arcnum); i++) {
          scanf("%d,%d,%d",&(*edges)[i].initial,
                &(*edges)[i].end, &(*edges[i].weight);
      }
  }
  //在assists数组中找到顶点point对应的位置下标
  int Locatevex(int vexnum,int point){
      for (int i=0; i<vexnum; i++) {
          if (assists[i].value==point) {
              return i;
          }
      }
      return -1;
  }
  int main(){
      int arcnum,vexnum;
      edge edges;
      CreateUDN(&edges,&vexnum,&arcnum);
      //对连通网中的所有边进行升序排序，结果仍保存在edges数组中
      qsort(edges, arcnum, sizeof(edges[0]), cmp);
      //创建一个空的结构体数组，用于存放最小生成树
      edge minTree;
      //设置一个用于记录最小生成树中边的数量的常量
      int num=0;
      //遍历所有的边
      for (int i=0; i<arcnum; i++) {
          //找到边的起始顶点和结束顶点在数组assists中的位置
          int initial=Locatevex(vexnum, edges[i].initial);
          int end=Locatevex(vexnum, edges[i].end);
          //如果顶点位置存在且顶点的标记不同，说明不在一个集合中，不会产生回路
          if (initial!=-1&& end!=-1&&assists[initial].sign!=assists[end].sign) {
              //记录该边，作为最小生成树的组成部分
              minTree[num]=edges[i];
              //计数+1
              num++;
              //将新加入生成树的顶点标记全不更改为一样的
              for (int k=0; k<vexnum; k++) {
                  if (assists[k].sign==assists[end].sign) {
                      assists[k].sign=assists[initial].sign;
                  }
              }
              //如果选择的边的数量和顶点数相差1，证明最小生成树已经形成，退出循环
              if (num==vexnum-1) {
                  break;
              }
          }
      }
      //输出语句
      for (int i=0; i<vexnum-1; i++) {
          printf("%d,%d\n",minTree[i].initial,minTree[i].end);
      }
      return 0;
  }
  ```

  

***

### 6、5有向无环图及其应用

- 一个无环的有向图称做有向无环图(directed acycline graph)，简称DAG图。

#### 拓扑排序













































***

## 7、内部排序

- 待排记录的数据类型设置为

  ```c
  #define MAXSIZE 20			//一个用作示例的小顺序表的最大长度
  typedef int KeyType;		//定义关键字类型为整数类型.
  typedef struct {
      KeyType key;			//关键字项
      InfoType other info;	//其他数据项
  } RedType ;//记录类型
  typedef struct {
      RedType r[MAXSIZE+ 1];	// r[0]闲置或用作哨兵单元
      int length;				//顺序表长度
  }SqList;//顺序表类型
  ```

***

### 7、1插入排序

#### 直接插入排序

- 先将序列中的第1个记录看成是一个有序的子序列
- 然后从第2个记录起逐个进行插人
- 直至整个序列变成按关键字非递减有序序列为止

```c
void Insertsort(SqList &L){
    for(p = 1;p < N;p ++){
        tmp = L[p];
        for(i = p;i > 0 && L[i-1]>tmp; i--)
            L[i] = L[i-1];
		L[i] = tmp;
    }
}
```

***

#### 其他插入排序

```c
void BInsertSort (SqList &L) {
    //对顺序表L作折半插人排序。
    for( i = 2;i <= L.length; ++i){
        L.r[0] = L.r[i]; 				//将L.r[i]暂存到L.x[0]
        low = 1;
        high = i - 1;
        while (low <= high) {			//在r[1ow...high]中折半查找有序插人的位置
            m = (low + high)/2;			//折半
            if (LT(L.r[0].key, L.r[m].key)) high = m-1;		// 插人点在低半区
            else low = m + 1;				//插人点在高半区
        }// while
        for ( j = i - 1; j >= high + 1; --j ) L.r[j+1] = L.r[j];		//记录后移
        L.r[high + 1] = L.r[0];			//插人
    }// for
} // BInsertSort
```

***

### 7、2希尔排序

- 它的基本思想是:
  - 先将整个待排记录序列分割成为若干子序列分别进行直接插人排序
  - 待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插人排序。

```c
void ShellInsert ( SqList &L, int dk ) {
    //对顺序表L作一趟希尔插人排序。本算法是和一趟直接插人排序相比,作了以下修改:
    //1.前后记录位置的增量是dk,而不是1;
    //2.r[0]只是暂存单元,不是哨兵。当j<<=0时,插人位置已找到。
    for ( i = dk + 1; i <= L.length; ++ i )
        if(LT(L.r[i].key, L.r[i-dk].key)) { // 需将L.r[i]插人有序增量子表
            L.r[0] = L.r[i];			//暂存在L.r[0]
            for (j = i - dk; j>0 && LT(L.r[0].key, L.r[j].key); j -= dk)
                L.r[j+dk] = L.r[j];		//记录后移,查找插人位置
            L.r[j+dk] = L.r[0];			//插人
        }
} // ShellInsert	
void ShellSort (SqList &L, int dlta[], int t) {
    //按增量序列dlta[0...t-1]对顺序表L作希尔排序。
    for (k = 0; k < t; ++ k)
    	ShellInsert(L, dlta[k]);
    //一趟增量为dlta[k]的插人排序
} // ShellSort
```

***

### 7、3快速排序

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\21.png" style="zoom:50%;" />

- 快速排序(QuickSort)是对起泡排序的一种改进

- 它的基本思想是,通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

  - 假设待排序的序列为{L. r[s],L. r[s+1],..,L. r[t]},首先任意选取一个记录(通常可选第一个记录L. r[s])作为枢轴(或支点)(pivot)

  - 然后按下述原则重新排列其余记录:

    - 将所有关键字较它小的记录都安置在它的位置之前

    - 将所有关键字较它大的记录都安置在它的位置之后

    - 由此可以该“枢轴”记录最后所落的位置 i 作分界线，将序列{L.r[s],.., L.r[t]}分割成两个子序列

      {L. r[s],L. r[s+1],..,L. r[i- 1]}和{L. r[i+1],L. r[i+2],.,L.r[t]}

```c
int Partition (SqList &L, int low, int high) {
    //交换顺序表L中子表L.r[1ow..high]的记录,使枢轴记录到位,并返回其所在位置,此时
    //在它之前(后)的记录均不大(小)于它。
    pivotkey = L.r[low].key;		//用子表的第一个记录作枢轴记录
    while (low < high) {				//从表的两端交替地向中间扫描
        while (low < high && L.r[high].key >= pivotkey) -- high;
        L.r[low]←-→L.r[high] ;		//将比枢轴记录小的记录交换到低端
        while (low < high && L.r[low].key <= pivotkey)	++ low; 
        L.r[1ow]←-→L.r[high];			//将比枢轴记录大的记录交换到高端
    }
    return low ;//返回枢轴所在位置
} // Partition
```



```c
int Partition (SqList &L, int low, int high) {
    //交换顺序表L中子表r[1ow..high]的记录,枢轴记录到位,并返回其所在位置,此时
    //在它之前(后)的记录均不大(小)于它。
    L.r[0] = L.r[low];			//用子表的第一个记录作枢轴记录
    pivotkey = L.r[low].key;	//枢轴记录关键字
    while (low<high) {			//从表的两端交替地向中间扫描
        while (low < high && L.r[high].key >= pivotkey) -- high;
        L.r[low] = L.r[high];		//将比枢轴记录小的记录移到低端
        while (low < high && L.r[low].key <= pivotkey) ++ low;
        L.r[high] = L.r[1ow]; 	//将比枢轴记录大的记录移到高端
    }
    L.r[low] = L.r[0];		//枢轴记录到位
    return 1ow;					//返回枢轴位置
} // Partition
```

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\22.png" style="zoom: 50%;" />

***

**递归形式的算法**

```c
void QSort (SqList &L, int low，int high) {
    //对顺序表L中的子序列L.r[1ow..high]作快速排序
    if (low < high) {			//长度大于1
        pivotloc = Partition(L, low, high) ;	//将L.x[1ow...high]一分为二
        QSort(L, low, pivotloc - 1);			//对低子表递归排序,pivotloc是枢轴位置
        QSort(L, pivotloc + 1, high) ;			//对高子表递归排序
    }
}// QSort
```

***

### 7、4选择排序

#### 简单选择排序

```c
void SelectSort (SqList &L) {
    //对顺序表L作简单选择排序。
    for (i = 1; i < L.length; ++ i) {	//选择第i小的记录,并交换到位
        j = SelectMinKey(L, i);		//在L.x[i. . L.1ength]中选择key最小的记录
        if (i!=j) L.r[i]←→L.r[j];	//与第i个记录交换
    }
} // SelectSort
```

***

#### 堆排序

![](C:\Users\13793\Desktop\学习笔记\数据结构\23.png)

- 若将和此序列对应的一维数组(即以一维数组作此序列的存储结构)看成是一个完全二叉树
  - 则堆的含义表明，完全二叉树中所有非终端结点的值均不大于(或不小于)其左、右孩子结点的值
  - 由此,若序列{k1,k2,..,kn}是堆，则堆顶元素(或完全二叉树的根)必为序列中n个元素的最小值(或最大值)

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\7E8U6DO@{B58K39VPEV[2AY.png" alt="img" style="zoom:50%;" />

- 若在输出堆顶的最小值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素中的次小值。
- 如此反复执行,便能得到一个有序序列,这个过程称之为**堆排序**。

**在输出堆顶元素后调整堆**

- 假设输出堆顶元素之后,以堆中最后一个元素替代之，如图10. 11(b)所示
- 此时根结点的左、右子树均为堆,则仅需自上至下进行调整即可。
  - 首先以堆顶元素和其左、右子树根结点的值比较之，由于右子树根结点的值小于左子树根结点的值且小于根结点的值，则将27和97交换之
  - 由于97替代了27之后破坏了右子树的“堆”，则需进行和上述相同的调整，直至叶子结点，调整后的状态
    如图10. 11(c)所示,
  - 此时堆顶为n-1个元素中的最小值。重复上述过程,将堆顶元素27和堆中最后一个元素97交换且调整,得到如图10. 11(d)所示新的堆。
  - 我们称这个自堆顶至叶子的调整过程为“筛选"。

<img src="C:\Users\13793\Desktop\学习笔记\数据结构\24.png" style="zoom:50%;" />

***

```c
typedef SqList HeapType;		//堆采用顺序表存储表示
void HeapAdjust (HeapType &H, int s, int m) {
    //已知H.r[s. .m]中记录的关键字除H.r[s].key之外均满足堆的定义,本函数调整H.r[s]
    //的关键字,使H.r[s...m]成为一个大顶堆(对其中记录的关键字而言)
    rc = H.r[s];
    for( j = 2*s; j <= m; j *= 2){							//沿key较大的孩子结点向下筛选.
        if ( j<m && LT(H.r[j].key, H.r[j+1].key) ) ++ j;		// j为key较大的记录的下标
        if ( !LT( rc.key, H.r[j].key) ) break;				// rc应插入在位置s_上
        H.r[s] = H.r[j]; s = j;
    }
    H.r[s] = rc;	//插入
} // HeapAdjust

void HeapSort ( HeapType &H ) {
	//对顺序表H进行堆排序。
    for ( i= H.1ength/2; i > 0; -- i )//把H.r[1.. H.1ength]建成大顶堆
    	HeapAdjust ( H, i, H.length );
    for ( i= H.length; i > 1; --i) {
    	H.r[1]←→H.r[i];		//将堆顶记录和当前未经排序子序列Hr[1.. i]中最后一个记录相互交换
    	HeapAdjust(H, 1, i- 1);//将H.r[1..i- 1]重新调整为大顶堆
    }
} // HeapSort
```

